---
id: "singlestream"
sidebar_position: 3
title: "Single stream"
---

import AdmonitionSimpleCode from "@site/docs/snippets/AdmonitionSimpleCode.mdx";

In this guide, we will show you how to create a single stream via the Proxy and Sablier's Proxy Target programmatically.

:::note

This guide assumes that you have already read both Lockup, [Linear](/contracts/v2/guides/create-stream/lockup-linear)
and [Dynamic](/contracts/v2/guides/create-stream/lockup-dynamic) Create Streams sections.

:::

<AdmonitionSimpleCode />

Creating a single stream through the `Proxy` is basically redirecting the call to the core contracts, while integrating
all systems used in Sablier V2, i.e. the `Proxy`, `Permit2`, `Proxy Target`, and `Core Contracts`.

## Create single functions

There are four create functions in the Proxy Target contract, two for each Lockup contract:

Lockup Linear:

- [`createWithDurations`](/contracts/v2/reference/core/contract.SablierV2LockupLinear#createwithdurations)
- [`createWithRange`](/contracts/v2/reference/core/contract.SablierV2LockupLinear#createwithrange)

Lockup Dynamic:

- [`createWithDeltas`](/contracts/v2/reference/core/contract.SablierV2LockupDynamic#createwithdeltas)
- [`createWithMilestones`](/contracts/v2/reference/core/contract.SablierV2LockupDynamic#createwithmilestones)

Let's start with a Lockup Linear example:

## Set up a contract

Declare the Solidity version used to compile the contract:

```solidity
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity >=0.8.19;
```

As mentioned in the [Overview](/contracts/v2/guides/proxy-architecture/overview), we use `Permit2` for all token
interactions. In our example we will deal with a contract creator, and contracts can't signt transactions. Having that
said, we will need an implementation of the [EIP-1271](https://eips.ethereum.org/EIPS/eip-1271) standard.

Let's declare a dummy contract `ERC1271` which returns the magic value (the function signature of `isValidSignature`):

```solidity
contract ERC1271 {
    function isValidSignature(bytes32, bytes memory) public pure returns (bytes4) {
        return this.isValidSignature.selector;
    }
}
```

Import the relevant symbols from `@sablier/v2-core` and `@sablier/v2-periphery`:

```solidity
import { ISablierV2LockupLinear } from "@sablier/v2-core/interfaces/ISablierV2LockupLinear.sol";
import { Broker, LockupLinear } from "@sablier/v2-core/types/DataTypes.sol";
import { ud2x18, ud60x18 } from "@sablier/v2-core/types/Math.sol";
import { IERC20 } from "@sablier/v2-core/types/Tokens.sol";
import { ISablierV2ProxyTarget } from "@sablier/v2-periphery/interfaces/ISablierV2ProxyTarget.sol";
import { IAllowanceTransfer, Permit2Params } from "@sablier/v2-periphery/types/Permit2.sol";
import { IPRBProxy, IPRBProxyRegistry } from "@sablier/v2-periphery/types/Proxy.sol";
```

Create a contract called `SingleLockupLinearStreamCreator` that inherits `ERC1271`, and declare a constant `DAI` of type
`IERC20`, a constant `PERMIT2` of type `IAllowanceTransfer`, a constant `PROXY_REGISTRY` of type `IPRBProxyRegistry`, an
immutable variable `lockupLinear` of type `ISablierV2LockupLinear` and an immutable variable `proxyTarget` of type
`ISablierV2ProxyTarget`:

```solidity
contract SingleLockupLinearStreamCreator is ERC1271 {
    IERC20 public constant DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);
    IAllowanceTransfer public constant PERMIT2 = IAllowanceTransfer(0x000000000022D473030F116dDEE9F6B43aC78BA3);
    IPRBProxyRegistry public constant PROXY_REGISTRY = IPRBProxyRegistry(0xD42a2bB59775694c9Df4c7822BfFAb150e6c699D);
    ISablierV2LockupLinear public immutable lockupLinear;
    ISablierV2ProxyTarget public immutable proxyTarget;
}
```

In the code above, the address of the [DAI](https://makerdao.com) stablecoin, Permit2 and Proxy Registry are hard-coded.
However, you would likely use an input parameter to allow the contract to change the assets it interacts with on a per
transaction basis. That being said, keep in mind that Permit2 is deployed at the same
[address](https://docs.uniswap.org/contracts/v3/reference/deployments) on all [chains](/contracts/v2/deployments) where
Sablier V2 is live, also Proxy Registry is deployed at the same address across these
[chains](https://prbproxy.com/deployments).

## Initialization

To initialize the Lockup Linear contract and the Proxy Target, you first need to grab their addresses from the
[Deployment Addresses](/contracts/v2/deployments) page. Once you have obtained them, pass them to the constructor of the
creator contract:

```solidity
constructor(ISablierV2LockupLinear lockupLinear_, ISablierV2ProxyTarget proxyTarget_) {
    lockupLinear = lockupLinear_;
    proxyTarget = proxyTarget_;
}
```

## Function definition

Define a function called `singleCreateLockupLinearStream` which takes a parameter `totalAmount`, and which returns the
id of the created stream:

```solidity
function singleCreateLockupLinearStream(uint256 totalAmount) public returns (uint256 streamId) {
    // ...
}
```

## Proxy Steps

We need to deploy a Proxy instance for the creator contract if it doesn't exists:

```solidity
// Get the proxy for this contract and deploy it if it doesn't exist
IPRBProxy proxy = PROXY_REGISTRY.getProxy({ owner: address(this) });
if (address(proxy) == address(0)) {
    proxy = PROXY_REGISTRY.deployFor(address(this));
}
```

## ERC-20 Steps

To create a stream, the caller must approve the creator contract to pull the tokens from the calling address's account.
Then, if the allowance is less than the transferred amount that the creator contract will be in possession from the
calling address (you), we have to approve the Permit2 contract. To take maximum advantage of Permit2, we should do a max
approval:

```solidity
// Transfer the provided amount of DAI tokens to this contract
DAI.transferFrom(msg.sender, address(this), totalAmount);

// Approve the Permit2 contract to spend DAI
uint256 allowance = DAI.allowance(address(this), address(PERMIT2));
if (allowance < totalAmount) {
    DAI.approve({ spender: address(PERMIT2), amount: type(uint256).max });
}
```

## Permit2 Steps

We are going to declare the Permit2 variables needed in the
[Proxy Target](/contracts/v2/reference/periphery/types/struct.Permit2Params).

```solidity
// Set up Permit2. See the full documentation at https://github.com/Uniswap/permit2
IAllowanceTransfer.PermitDetails memory permitDetails;
permitDetails.token = address(DAI);
permitDetails.amount = uint160(totalAmount);
permitDetails.expiration = type(uint48).max; // maximum expiration possible
(,, permitDetails.nonce) = PERMIT2.allowance({ user: address(this), token: address(DAI), spender: address(proxy) });

IAllowanceTransfer.PermitSingle memory permitSingle;
permitSingle.details = permitDetails;
permitSingle.spender = address(proxy); // the proxy will be the spender
permitSingle.sigDeadline = type(uint48).max; // same deadline as expiration

// Declare the Permit2 params needed by Sablier
Permit2Params memory permit2Params;
permit2Params.permitSingle = permitSingle;
permit2Params.signature = bytes("");
```

In the code above, we passed a null bytes because contracts can't sign transactions. If you were to use an EOA, a valid
signature would be required.

You can find the documentation for the Permit2 structs on Uniswap's
[website](https://docs.uniswap.org/contracts/permit2/reference/allowance-transfer).

## Parameters

We need to define the create function parameters. Let's use the same ones we've previously declared in the
[Create Stream](/contracts/v2/guides/create-stream/lockup-linear#parameters) section:

```solidity
// Declare the create function params
LockupLinear.CreateWithDurations memory createParams;
createParams.sender = msg.sender; // The sender will be able to cancel the stream
createParams.recipient = address(0xcafe); // The recipient of the streamed assets
createParams.totalAmount = uint128(totalAmount); // Total amount is the amount inclusive of all fees
createParams.asset = DAI; // The streaming asset is DAI
createParams.cancelable = true; // Whether the stream will be cancelable or not
createParams.durations = LockupLinear.Durations({
    cliff: 4 weeks, // Assets will be unlocked only after 4 weeks
    total: 52 weeks // Setting a total duration of ~1 year
    });
createParams.broker = Broker(address(0), ud60x18(0)); // Optional parameter left undefined
```

The only difference here is that we've named the struct `createParams` instead of `params`. This is because we have
multiple parameters in the target's create
[function](/contracts/v2/reference/periphery/interfaces/interface.ISablierV2ProxyTarget#createwithdurations).

## Create a single stream

Due to the nature of `delegatecall`, it's necessary to encode the parameters declared above into `bytes`:

```solidity
bytes memory data = abi.encodeCall(proxyTarget.createWithDurations, (lockupLinear, createParams, permit2Params));
```

Once this set-up is complete, we can create a single stream via the Proxy and Sablier's Proxy Target:

```solidity
bytes memory response = proxy.execute(address(proxyTarget), data);
```

To return the `streamId` we need to decode the response to `uint256`:

```solidity
streamId = abi.decode(response, (uint256));
```

## The complete Single Lockup Linear stream creator contract

Below you can see the complete functioning code: a contract that creates Lockup Linear single streams via the Proxy and
Sablier's Proxy Target that start at `block.timestamp`. You can access the code on GitHub through this
[link](https://github.com/sablier-labs/examples/blob/main/v2/periphery/SingleLockupLinearStreamCreator.sol).

```solidity reference title="Single Lockup Linear stream creator"
https://github.com/sablier-labs/examples/blob/main/v2/periphery/SingleLockupLinearStreamCreator.sol
```

<hr style={{ borderTop: "1px solid black" }} />

For the Lockup Dynamic example, we can apply the same steps as above, we won't detail each step again here.

The difference compared to the Lockup Linear example is that we have two `amount` parameters that need to be summed
together, as explained in the [Create Stream](/contracts/v2/guides/create-stream/lockup-dynamic#function-definition)
section.

```solidity
function singleCreateLockupDynamicStream(uint256 amount0, uint256 amount1) public returns (uint256 streamId) {
    /// ...

    // Sum the segment amounts
    uint256 totalAmount = amount0 + amount1;
}
```

Of course, we've also declared a different create struct:

```solidity
// Declare the create function params
LockupDynamic.CreateWithMilestones memory createParams;
```

## The complete Single Lockup Dynamic stream creator contract

Below you can see the complete functioning code: a contract that creates Lockup Dynamic single streams via the Proxy and
Sablier's Proxy Target with predefined segment milestones. You can access the code on GitHub through this
[link](https://github.com/sablier-labs/examples/blob/main/v2/periphery/SingleLockupDynamicStreamCreator.sol).

```solidity reference title="Single Lockup Dynamic stream creator"
https://github.com/sablier-labs/examples/blob/main/v2/periphery/SingleLockupDynamicStreamCreator.sol
```

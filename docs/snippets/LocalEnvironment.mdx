{/* eslint-disable react/prop-types */}

import Link from "@docusaurus/Link";

export const Introduction = ({ protocol }) => (
  <>
    In this guide, we will go through the steps to set up a local development environment for building onchain
    integrations with {protocol}. We will use Foundry to install {protocol} as a dependency, and run a simple test.
    <br />
    <br />
    At the end, you’ll have a development environment set up that you can use to build the rest of the examples under
    &quot;Guides&quot;, or start your own integration project.
  </>
);

export const Prerequisite = () => (
  <>
You will need the following software on your machine:

<br />
<br />

<ul>
  <li>
    <Link href="https://git-scm.com/downloads">Git</Link>
  </li>
  <li>
    <Link href="https://github.com/foundry-rs/foundry">Foundry</Link>
  </li>
  <li>
    <Link href="https://nodejs.org/en/download">Node.js</Link>
  </li>
  <li>
    <Link href="https://bun.sh">Bun</Link>
  </li>
</ul>

In addition, familiarity

with <Link href="https://ethereum.org/">Ethereum</Link> and <Link href="https://soliditylang.org/">Solidity</Link> is
requisite.

</>
);

export const SetupWithTemplate = ({ protocol }) => (
  <>

We put together a template repository that you can use to get started quickly. This repository features a basic project
structure, pre-configured {protocol} imports, and a selection of sample contracts and tests.

<br />
<br />

To install the template, simply execute the following commands:

<br />
<br />

<pre>
  <code>
    $ mkdir {protocol.toLowerCase()}-integration-template
    <br />$ cd {protocol.toLowerCase()}-integration-template
    <br />$ forge init --template sablier-labs/{protocol.toLowerCase()}-integration-template
    <br />$ bun install
  </code>
</pre>

Then, hop to the <Link href="#run-a-fork-test">Run a Fork Test</Link> section to complete your set up and start
developing.

</>
);

export const SetupWithFoundry = ({ protocol }) => (
<>
Foundry is a popular development toolkit for Ethereum projects, which we have used to build the {protocol} Protocol. For
the purposes of this guide, Foundry will provide us with the tooling needed to compile and test our contracts.

<br />
<br />

Let&apos;s use this command to spin up a new Foundry project:

<br />
<br />

<pre>
  <code>
    $ forge init my-project
    <br />$ cd my-project
  </code>
</pre>

Once the initialization completes, take a look around at what got set up:

<br />
<br />

<pre>
  <code>
    ├── foundry.toml
    <br />
    ├── script
    <br />
    ├── src
    <br />
    └── test
  </code>
</pre>

The folder structure should be intuitive:

<br />
<br />

<ul>
  <li>
    <code>src</code> is where you&apos;ll write Solidity contracts
  </li>
  <li>
    <code>test</code> is where you&apos;ll write tests (also in Solidity)
  </li>
  <li>
    <code>script</code> is where you&apos;ll write scripts to perform actions like deploying contracts (you guessed it,
    in Solidity)
  </li>
  <li>
    <code>foundry.toml</code> is where you can configure your Foundry settings, which we will leave as is in this guide
  </li>
</ul>

</>
);

export const InstallNpm = ({ protocol }) => (
  <>

Let&apos;s install the {protocol} Node.js packages using Bun:

<br />
<br />

<pre>
  <code>
    $ bun add @sablier/{protocol.toLowerCase()}
    <br />
  </code>
</pre>

Bun will download the {protocol} contracts, along with their dependencies,

and put them in the <code>node_modules</code> directory.

<br />
<br />

Let&apos;s remap the package names to point to the installed contracts. This step is required so that the Solidity
compiler can find the {protocol} contracts when you import them:

<br />
<br />

<pre>
  <code>
    $ echo &quot;@sablier/{protocol.toLowerCase()}=node_modules/@sablier/{protocol.toLowerCase()}/&quot; &gt;&gt;
    remappings.txt
    <br />$ echo &quot;@openzeppelin/contracts/=node_modules/@openzeppelin/contracts/&quot; &gt;&gt; remappings.txt
    <br />$ echo &quot;@prb/math/=node_modules/@prb/math/&quot; &gt;&gt; remappings.txt
  </code>
</pre>

That&apos;s it! You should now have a functional development environment to start building onchain {protocol}
integrations. Let&apos;s run a quick test to confirm everything is set up properly.

      </>

);

export const FirstContract1 = () => (
  <>
Delete the <code>src/Counter.sol</code> and <code>test/Counter.t.sol</code> files generated by Forge, and create two new files:
<br />
<code>src/StreamCreator.sol</code> and <code>test/StreamCreator.t.sol</code>.

<br />
<br />

Paste the following code into <code>src/StreamCreator.sol</code>:

<br />
<br />

</>
);

export const FirstContract2 = () => (
  <>

Let&apos;s use Forge to compile this contract:

<pre>
  <code>
    $ forge build
    <br />
  </code>
</pre>

If the contract was compiled correctly, you should see this message:

<pre>
  <code>
    [⠢] Compiling...
    <br />
    [⠰] Compiling 62 files with Solc 0.8.26
    <br />
    [⠒] Solc 0.8.26 finished in 967.04ms
    <br />
    Compiler run successful!
  </code>
</pre>

  </>

);

export const RunForkTest1 = () => (
  <>
Foundry offers native support for running tests against a fork of Ethereum Mainnet, testnets and L2s, which is useful
when building and testing integrations with onchain protocols like Sablier. In practice, this enables you to access all
Sablier contracts deployed on Ethereum, and use them for testing your integration.

<br />
<br />

As a prerequisite, you will need an RPC that supports forking.

A good solution for this is <Link href="https://alchemy.com/">Alchemy</Link>, as it includes forking in its free tier
plan.

<br />
<br />

Once you have obtained your RPC, you can proceed to run the following test:

<br />
<br />

  </>

);

export const RunForkTest2 = ({ protocol }) => (
  <>
You can run the test using Forge:

<br />
<br />

<pre>
  <code>
    $ forge test
    <br />
  </code>
</pre>

If the test passed, you should see a message like this:

<br />
<br />

<pre>
  <code>
    Ran 2 tests for test/{protocol}StreamCreator.t.sol:{protocol}StreamCreatorTest
    <br />
    [PASS] test_Create{protocol}Stream() (gas: 246830)
    <br />
    Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 626.58ms (500.67µs CPU time)
    <br />
  </code>
</pre>

  </>

);

export const FinalSteps = ({ protocol }) => (
  <>
Congratulations! Your environment is now configured, and you are prepared to start building. Explore the guides section
to discover various features available for {protocol} integration. Remember to include all contracts (<code>.sol</code> files) in the <code>src</code>
folder and their corresponding tests in the <code>test</code> folder.

<br />
<br />

As far as Foundry is concerned, there is much more to uncover. If you want to learn more about it,

check out the <Link href="https://book.getfoundry.sh/">Foundry Book</Link>, which contains numerous examples and
tutorials. A deep understanding of Foundry will enable you to create more sophisticated integrations

with {protocol} protocol.

  </>

);

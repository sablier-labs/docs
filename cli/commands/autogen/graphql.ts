import fs from "node:fs";
import { join } from "node:path";
import type { Indexer } from "@sablier/indexers";
import { getIndexerEnvio, getIndexerGraph } from "@sablier/indexers";
import { Command } from "commander";
import $ from "execa";
import * as yaml from "js-yaml";
import _ from "lodash";
import type { CliOptions } from "../../types";

const CHAIN_ID_SEPOLIA = 11155111;

type Category = {
  /** @see https://docusaurus.io/feature-requests/p/hiding-parts-of-docs-in-autogenerated-sidebar */
  className?: "hidden";
  collapsible: boolean;
  collapsed: boolean;
  label: string;
  position: number;
};

type GraphQLOptions = CliOptions & {
  protocol: string;
  vendor: string;
};

/* -------------------------------------------------------------------------- */
/*                                   COMMAND                                  */
/* -------------------------------------------------------------------------- */

export function createGraphQLCommand() {
  return new Command("graphql")
    .description("Generate GraphQL schema documentation")
    .requiredOption("-p, --protocol <protocol>", "generate for specific protocol")
    .requiredOption("-v, --vendor <vendor>", "generate for specific vendor")
    .action(async function () {
      const parentOptions = this.parent ? this.parent.opts() : {};
      const commandOptions = this.opts();
      const mergedOptions: GraphQLOptions = { ...parentOptions, ...commandOptions };
      await generateGraphQL(mergedOptions);
    });
}

export const graphQLCmd = createGraphQLCommand();

export async function generateGraphQL(options: GraphQLOptions): Promise<void> {
  const protocols: Indexer.Protocol[] = ["airdrops", "flow", "lockup"];
  const vendors = ["graph", "envio"];

  if (options.protocol !== "all" && !protocols.includes(options.protocol as Indexer.Protocol)) {
    throw new Error(`Invalid protocol: ${options.protocol}. Valid options: ${protocols.join(", ")}, all`);
  }
  if (options.vendor !== "all" && !vendors.includes(options.vendor as Indexer.Vendor)) {
    throw new Error(`Invalid vendor: ${options.vendor}. Valid options: ${vendors.join(", ")}, all`);
  }

  let targetProtocols = protocols;
  if (options.protocol !== "all") {
    targetProtocols = _.filter(protocols, (p) => p === options.protocol);
  }

  const docsPaths: string[] = [];
  for (const p of targetProtocols) {
    if (options.vendor === "all" || options.vendor === "graph") {
      const docsPath = await generateGraph(p);
      docsPaths.push(docsPath);
      await runPrettier(docsPath);
    }
    if (options.vendor === "all" || options.vendor === "envio") {
      const docsPath = await generateEnvio(p);
      docsPaths.push(docsPath);
      await runPrettier(docsPath);
    }
  }

  cleanupDocs(docsPaths);
}

/* -------------------------------------------------------------------------- */
/*                               INTERNAL LOGIC                               */
/* -------------------------------------------------------------------------- */

const COLLAPSED = {
  collapsed: true,
  collapsible: true,
};

const THE_GRAPH_CATEGORY: Category = { ...COLLAPSED, label: "The Graph", position: 2 };
const ENVIO_CATEGORY: Category = { ...COLLAPSED, label: "Envio", position: 3 };
const OBJECTS_CATEGORY: Category = { ...COLLAPSED, label: "Objects", position: 2 };
const QUERIES_CATEGORY: Category = { ...COLLAPSED, className: "hidden", label: "Query Syntax", position: 3 }; // first is the overview
const ENUMS_CATEGORY: Category = { ...COLLAPSED, className: "hidden", label: "Enums", position: 4 };
const INPUTS_CATEGORY: Category = { ...COLLAPSED, className: "hidden", label: "Inputs", position: 5 };
const SCALARS_CATEGORY: Category = { ...COLLAPSED, className: "hidden", label: "Scalars", position: 6 };

function cleanupDocs(docsPaths: string[]): void {
  for (const docsPath of docsPaths) {
    fs.rmSync(join(docsPath, "directives"), { force: true, recursive: true });
    fs.rmSync(join(docsPath, "subscriptions"), { force: true, recursive: true });

    // Delete all _category_.yml files
    fs.unlinkSync(join(docsPath, "enums", "_category_.yml"));
    fs.unlinkSync(join(docsPath, "inputs", "_category_.yml"));
    fs.unlinkSync(join(docsPath, "objects", "_category_.yml"));
    fs.unlinkSync(join(docsPath, "queries", "_category_.yml"));
    fs.unlinkSync(join(docsPath, "scalars", "_category_.yml"));

    // Rewrite _category_.yml files
    fs.writeFileSync(join(docsPath, "enums", "_category_.yml"), yaml.dump(ENUMS_CATEGORY));
    fs.writeFileSync(join(docsPath, "inputs", "_category_.yml"), yaml.dump(INPUTS_CATEGORY));
    fs.writeFileSync(join(docsPath, "objects", "_category_.yml"), yaml.dump(OBJECTS_CATEGORY));
    fs.writeFileSync(join(docsPath, "queries", "_category_.yml"), yaml.dump(QUERIES_CATEGORY));
    fs.writeFileSync(join(docsPath, "scalars", "_category_.yml"), yaml.dump(SCALARS_CATEGORY));

    // Write vendor category file at base path
    if (docsPath.includes("envio")) {
      fs.writeFileSync(join(docsPath, "_category_.yml"), yaml.dump(ENVIO_CATEGORY));
    } else if (docsPath.includes("the-graph")) {
      fs.writeFileSync(join(docsPath, "_category_.yml"), yaml.dump(THE_GRAPH_CATEGORY));
    }
  }
}

async function generateEnvio(protocol: Indexer.Protocol): Promise<string> {
  const docsPath = `./docs/api/${protocol}/graphql/envio`;
  const schemaURL = getIndexerEnvio({ chainId: CHAIN_ID_SEPOLIA, protocol }).endpoint.url;

  await runCommand(docsPath, schemaURL);
  console.log(`✔️  Generated GraphQL docs for Envio vendor and ${_.capitalize(protocol)} protocol\n`);
  return docsPath;
}

async function generateGraph(protocol: Indexer.Protocol): Promise<string> {
  const docsPath = `./docs/api/${protocol}/graphql/the-graph`;
  const schemaURL = getIndexerGraph({ chainId: CHAIN_ID_SEPOLIA, protocol }).testingURL;

  await runCommand(docsPath, schemaURL);
  console.log(`✔️  Generated GraphQL docs for The Graph vendor and ${_.capitalize(protocol)} protocol\n`);
  return docsPath;
}

/**
 * @see https://graphql-markdown.dev/docs/settings#baseurl
 * @see {@link file://./../../../config/plugins.ts}
 */
async function runCommand(base: string, schema: string): Promise<void> {
  const options = ["--base", base, "--schema", schema];
  await $("bun", ["docusaurus", "graphql-to-doc", ...options], { stdio: "inherit" });
}

async function runPrettier(targetPath: string): Promise<void> {
  await $("bun", ["prettier", "--cache", "--write", `${targetPath}/**/*.{md,mdx,yml,yaml}`]);
}

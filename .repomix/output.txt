This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: ./**/*.mdx
- Files matching these patterns are excluded: docs/reference, repos
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
docs/
  api/
    02-lockup/
      02-envio/
        01-similarities.mdx
      03-the-graph/
        01-entities.mdx
        02-structure.mdx
      01-indexers.mdx
      04-previous-indexers.mdx
    03-airdrops/
      02-merkle-api/
        01-overview.mdx
        02-functionality.mdx
        03-examples.mdx
      03-the-graph/
        01-entities.mdx
      04-envio/
        01-similarities.mdx
      01-indexers.mdx
      05-previous-indexers.mdx
    04-flow/
      02-the-graph/
        01-entities.mdx
        02-structure.mdx
      03-envio/
        01-similarities.mdx
        02-queries.mdx
      01-indexers.mdx
      04-previous-indexers.mdx
    01-overview.mdx
    05-development.mdx
    06-caveats.mdx
    07-legacy.mdx
  apps/
    features/
      02-vesting.mdx
    guides/
      01-csv-support.mdx
      02-url-schemes.mdx
      03-how-to.mdx
    03-branding.mdx
    04-legacy-v1.mdx
  concepts/
    lockup/
      02-stream-shapes.mdx
    01-what-is-sablier.mdx
    03-use-cases.mdx
    05-merkle-airdrops.mdx
    07-chains.mdx
    08-nft.mdx
    12-fees.mdx
  guides/
    airdrops/
      examples/
        01-local-environment.mdx
        02-create-campaign.mdx
      02-airdrops-deployments.mdx
    flow/
      examples/
        01-local-environment.mdx
        02-calculate-rps.mdx
        03-create-stream.mdx
        04-stream-management.mdx
        05-batchable.mdx
      previous-deployments/
        v1.0.mdx
      02-flow-deployments.mdx
      04-gas-benchmarks.mdx
    legacy/
      03-codebase.mdx
    lockup/
      examples/
        batch-create-streams/
          01-batch-lockup-linear.mdx
          02-batch-lockup-dynamic.mdx
          03-batch-lockup-tranched.mdx
        create-stream/
          01-lockup-linear.mdx
          02-lockup-tranched.mdx
          03-lockup-dynamic.mdx
        01-local-environment.mdx
      previous-deployments/
        v1.0.mdx
        v1.1.mdx
        v1.2.mdx
      02-lockup-deployments.mdx
      04-gas-benchmarks.mdx
    04-custom-deployments.mdx
  support/
    01-faq.mdx
    02-technical-guides.mdx
    03-how-to.mdx
src/
  snippets/
    AdmonitionSimpleCode.mdx
    BatchCommonSteps.mdx
    DeprecatedIndexers.mdx
    ExplainerEnvio.mdx
    ExplainerTheGraph.mdx
    LocalEnvironment.mdx
    LockupParams.mdx
    ReleaseHistoryAirdrops.mdx
    ReleaseHistoryFlow.mdx
    ReleaseHistoryLegacy.mdx
    ReleaseHistoryLockup.mdx
    TokenApproval.mdx

================================================================
Files
================================================================

================
File: docs/api/02-lockup/02-envio/01-similarities.mdx
================
---
draft: true
id: "similarities"
sidebar_position: 1
title: "Similarities"
---

# Similarities

Envio indexers are designed to mirror the functionality and structure of the The Graph subgraphs.

For an introduction into the Sablier primitives and our architectural choices, check out the
[Lockup subgraph](/api/lockup/the-graph/entities) before reading about the `lockup-envio` indexer.

Similar entities are used between The Graph and Envio setups, as well as between the Lockup and Merkle deployments.

- [Entities](/api/lockup/the-graph/entities)
- [Structure](/api/lockup/the-graph/structure)

================
File: docs/api/02-lockup/03-the-graph/01-entities.mdx
================
---
draft: true
id: "entities"
sidebar_position: 1
title: "Entities"
---

## Entity Architecture

GraphQL entities defined by the Sablier subgraphs are meant to mirror the functionality exposed by our core lockup
contracts. To achieve this, events are stored as historical entries (e.g. Action) while also being used to mutate
attributes for live entities (e.g. Stream).

Inside the **Lockup** subgraph, the `schema.graphql` file is responsible of defining the following Sablier entities:

### Primary

| Entity  | Description                                                                            |
| ------- | -------------------------------------------------------------------------------------- |
| Action  | Emitted events transformed into historical entries (e.g. Create, Withdraw)             |
| Stream  | Primary entity tracking the up to date state of a stream                               |
| Asset   | The ERC20 asset that is being streamed                                                 |
| Segment | The function segment used to build the custom curve in cases of Lockup Dynamic streams |
| Tranche | The tranche/step used to build shapes powered by Lockup Tranched streams               |

### Secondary

| Entity  | Description                                                                                                     |
| ------- | --------------------------------------------------------------------------------------------------------------- |
| Batch   | An entity grouping a set of stream created all at once (action done through the `lockup-periphery`)             |
| Batcher | An entity resolving 1:1 to a stream sender, in charge of managing the count of "batches" of streams one creates |
| Watcher | A singleton data store for subgraph-level unique indexes such as the stream or action index                     |

================
File: docs/api/02-lockup/03-the-graph/02-structure.mdx
================
---
draft: true
id: "structure"
sidebar_position: 2
title: "Structure"
---

We'll break down the [schema](https://github.com/sablier-labs/indexers/blob/main/the-graph/lockup/schema.graphql) into
primary and secondary entities.

| Type      | Entities                                |
| --------- | --------------------------------------- |
| Primary   | Action, Stream, Asset, Segment, Tranche |
| Secondary | Batch, Batcher, Watcher                 |

---

## Action

Events emitted by the Sablier Lockup contracts will:

1. Be used to mutate the data stored in the individual `Stream` entities
2. Be stored as historical logs (list of `Action`) to show the evolution of a related stream

Based on the schema defined `ActionCategory`, the following actions will be tracked by the subgraph:

| Action         | Contract Events                                     |
| -------------- | --------------------------------------------------- |
| Approval       | Approval                                            |
| ApprovalForAll | ApprovalForAll                                      |
| Create         | CreateLockupLinearStream, CreateLockupDynamicStream |
| Cancel         | CancelLockupStream                                  |
| Renounce       | RenounceLockupStream                                |
| Transfer       | Transfer                                            |
| Withdraw       | WithdrawFromLockupStream                            |

To keep all actions under the same umbrella, some details will be stored under general purpose attributes like
`amountA`, `amountB`, `addressA`, `addressB` which based on the type of action can be resolved to context-specific
values. Am example can be found
[here](https://github.com/sablier-labs/indexers/blob/main/the-graph/lockup/src/mappings/handle-stream.ts#L79-L82) for the
Cancel event.

---

## Stream

### Identifying

Inside the contracts, streams will be assigned a unique `tokenId` (or `streamId`). While this makes it easy to identify
items at the contract level, we need to consider the following for both subgraphs and client interfaces:

- items should be uniquely recognizable across multiple contract instances
- items should be uniquely identifiable across multiple chains
- items should be identifiable with short, easy to digest names

To address these observations, the subgraph uses two related identifiers for a Stream.

| Type           | Description                                                                                         | Example                        |
| -------------- | --------------------------------------------------------------------------------------------------- | ------------------------------ |
| `Stream.id`    | A self-explanatory structure built using the following structure: `contractAddress-chainId-tokenId` | <nobr>`0xAB..12-137-21`</nobr> |
| `Stream.alias` | A short version of the `id` where the contract is aliased: `contractAlias-chainId-tokenId`          | <nobr>`LK-137-21`</nobr>       |

Both examples from the table above translate to: **_a stream on Polygon (chain id `137`), within the Lockup Merged
contract at address `0xAB..12`, with the tokenId `21`_**.

:::note

The aliases defined in the subgraph will be used by client apps to resolve data about a stream. Make sure to keep them
in sync, avoid conflicts and regard them as immutable (once decided, never change them).

:::

### Aliases

:::important

Following the merger of LockupLinear, LockupDynamic, and LockupTranched into a single contract, the alias for all
streaming shapes was standardized as `LK`.

:::

To provide a simple visual structure, while also accounting for future stream curves (backwards compatibility) we use
the following abbreviations as aliases:

- Lockup v2.0 contracts become `LK`, e.g `LK-137-1`
- Lockup v1.0 Linear contracts become `LL`, e.g. `LL-137-1`
- Lockup v1.1 Linear contracts become `LL2`, e.g. `LL2-137-1`
- Lockup v1.2 Linear contracts become `LL3`, e.g. `LL3-137-1`
- Lockup v1.0 Dynamic contracts become `LD`, e.g. `LD-137-1`
- Lockup v1.1 Dynamic contracts become `LD2`, e.g. `LD2-137-1`
- Lockup v1.2 Dynamic contracts become `LD3`, e.g. `LD3-137-1`
- Lockup v1.2 Tranched contracts become `LT`, e.g. `LT3-137-1`

More on contract iterations and past versions [here](/guides/lockup/deployments#versions).

### Relevant parties

Within the larger Sablier ecosystem, the number of relevant entities participating in a stream (and the dynamics between
them) has grown past the immutable `sender` and `recipient`. Therefore, we identify the following parties involved in a
stream.

#### The recipient (gets paid\*)

As funds are being streamed, they will slowly become eligible to withdraw and spend unlocked tokens. The `recipient` is
defined at the start of the stream but can change as a result of a transfer.

On transfer, the old recipient moves the NFT (the stream itself) to another address, which becomes the new recipient.
Rights to withdraw and claim future streamed funds are naturally transferred to this new address.

#### The sender (will pay\*)

They are an immutable party, defined at the start of the stream. Based on the configuration chosen for the stream, they
will be entitled to later cancel the stream, renounce it (disable cancelability) or withdraw on behalf of the recipient.

In case of a cancelation, the `sender` will receive any unstreamed tokens as part of the refund.

#### The funder

When the stream is created, they provide the tokens to be gradually streamed to the recipient. Usually, they are the
same entity as the sender. However, there may be cases when someone wishes to create a stream on another user's behalf,
while also marking them as the sender. In that case, this initial address will be accounted for as the stream's
`funder`.

---

## Asset

Tokens (ERC20) streamed through the protocol will be defined through an `Asset` entity.

:::info

As a development caveat, some ERC20 contracts are designed to store details (e.g. name, symbol) as `bytes32` and not
`string`. Prior to deploying a subgraph, make sure you take into account these details as part of any Asset entity
implementation. For examples, see the asset "helper" files inside this subgraph's repository code.

:::

---

## Segment

The custom emission curve used by Lockup Dynamic streams will be defined as a sequence of
[segments](/concepts/lockup/segments). This entity will store data regarding those segments, which will be later used to
reconstruct the shape of the curve client side.

---

## Tranche

The custom emission curve used by Lockup Tranched streams will be defined as a sequence of
[tranches](/concepts/lockup/tranches). This entity will store data regarding those tranches, which will be later used to
reconstruct the shape of the curve client side.

:::tip

Tranches can also be represented as a set of two segments (one horizontal, one vertical) so client apps may benefit from
artificially creating segments from tranches.

:::

---

## Batch and Batcher

The lockup-periphery, while not explicitly tracked by the subgraph will offer some extra functionality to proxy-sourced
streams. One of these functionalities will be **batch stream creation** (or **stream grouping**). Using methods like
`createWithDurations` or `createWithTimestamps` a sender will be able to create multiple streams at once - considered
part of the same batch.

To identify these relationships between stream items, the `Batch` entity will group items created in the same
transaction, by finding events emitted with the same tx hash. The `Batcher` will then assign a user-specific unique
index to every group.

---

## Watcher

The Watcher (one for the entire subgraph) will provide specific utilities to the entire system, like global stream
identifiers (a numeric id unique to a stream across all contract instances) and global action identifiers.

================
File: docs/api/02-lockup/01-indexers.mdx
================
---
id: "indexers"
sidebar_position: 1
title: "Indexers"
---

import TableEnvio from "@site/src/autogen/lockup/TableEnvio.mdx";
import TableTheGraph from "@site/src/autogen/lockup/TableTheGraph.mdx";
import LinkPreviewIndexers from "@site/src/components/molecules/link-previews/Indexers";
import ExplainerEnvio from "@site/src/snippets/ExplainerEnvio.mdx";
import ExplainerTheGraph from "@site/src/snippets/ExplainerTheGraph.mdx";

# Sablier Lockup

This page documents the indexers for the [Sablier Lockup](/concepts/lockup/overview) protocol, which powers the [Vesting](/apps/features/vesting) product and some of the [Airdrop](/apps/features/airdrops) product features in the Sablier Interface.

## Envio

### Source Code

<LinkPreviewIndexers vendor="envio" protocol="lockup" />

### Endpoints

<ExplainerEnvio />

<TableEnvio />

## The Graph

### Source Code

<LinkPreviewIndexers vendor="graph" protocol="lockup" />

### Endpoints

<ExplainerTheGraph />

<TableTheGraph />

================
File: docs/api/02-lockup/04-previous-indexers.mdx
================
---
id: "previous-indexers"
sidebar_position: 4
title: "Previous Indexers"
---

import DeprecatedIndexers from "@site/src/snippets/DeprecatedIndexers.mdx";

<DeprecatedIndexers />

| Chain            | Explorer                                                    | Studio[^2]                           | Decentralized Network[^1]               |
| ---------------- | ----------------------------------------------------------- | ------------------------------------ | --------------------------------------- |
| Ethereum         | [sablier-v2][v2-explorer-ethereum]                          | [Studio][v2-studio-ethereum]         | [Network][v2-network-ethereum]          |
| Arbitrum         | [sablier-v2-arbitrum][v2-explorer-arbitrum]                 | [Studio][v2-studio-arbitrum]         | [Network][v2-network-arbitrum]          |
| Arbitrum Sepolia | [sablier-v2-arbitrum-sepolia][v2-explorer-arbitrum-sepolia] | [Studio][v2-studio-arbitrum-sepolia] | [Network][v2-network-arbitrum-sepolia]  |
| Avalanche        | [sablier-v2-avalanche][v2-explorer-avalanche]               | [Studio][v2-studio-avalanche]        | [Network][v2-network-avalanche]         |
| Base             | [sablier-v2-base][v2-explorer-base]                         | [Studio][v2-studio-base]             | [Network][v2-network-base]              |
| Blast            | [sablier-v2-blast][v2-explorer-blast]                       | [Studio][v2-studio-blast]            | [Network][v2-network-blast]             |
| BNB Chain        | [sablier-v2-bsc][v2-explorer-bsc]                           | [Studio][v2-studio-bsc]              | [Network][v2-network-bsc]               |
| Chliz Chain      | [sablier-v2-chiliz][v2-explorer-chiliz]                     | [Studio][v2-studio-chiliz]           | [Network][v2-network-chiliz]            |
| Gnosis           | [sablier-v2-gnosis][v2-explorer-gnosis]                     | [Studio][v2-studio-gnosis]           | [Network][v2-network-gnosis]            |
| Lightlink        | [sablier-v2-lightlink\*][v2-explorer-lightlink]             | N/A                                  | [Lightlink Node\*][v2-custom-lightlink] |
| Optimism         | [sablier-v2-optimism][v2-explorer-optimism]                 | [Studio][v2-studio-optimism]         | [Network][v2-network-optimism]          |
| Optimism Sepolia | [sablier-v2-optimism-sepolia][v2-explorer-optimism-sepolia] | [Studio][v2-studio-optimism-sepolia] | [Network][v2-network-optimism-sepolia]  |
| Polygon          | [sablier-v2-polygon][v2-explorer-polygon]                   | [Studio][v2-studio-polygon]          | [Network][v2-network-polygon]           |
| Scroll           | [sablier-v2-scroll][v2-explorer-scroll]                     | [Studio][v2-studio-scroll]           | [Network][v2-network-scroll]            |
| Ethereum Sepolia | [sablier-v2-sepolia][v2-explorer-sepolia]                   | [Studio][v2-studio-sepolia]          | [Network][v2-network-sepolia]           |
| zkSync           | [sablier-v2-zksync][v2-explorer-zksync]                     | [Studio][v2-studio-zksync]           | [Network][v2-network-zksync]            |

{/* --------------------------------------------------------------------------------------------------------------------------------- */}
{/* --------------------------------------------------------------------------------------------------------------------------------- */}
{/* --------------------------------------------------------------------------------------------------------------------------------- */}

{/* Chain: Arbitrum */}

[v2-network-arbitrum]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/8BnGPBojHycDxVo83LP468pUo4xDyCQbtTpHGZXR6SiB
[v2-explorer-arbitrum]: https://thegraph.com/explorer/subgraphs/8BnGPBojHycDxVo83LP468pUo4xDyCQbtTpHGZXR6SiB
[v2-studio-arbitrum]: https://api.studio.thegraph.com/query/57079/sablier-v2-arbitrum/version/latest

{/* Chain: Arbitrum Sepolia */}

[v2-network-arbitrum-sepolia]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/BZYXgTYGe51dy5rW6LhrLN7PWSiAgRQoqSBJEiPpRN9K
[v2-explorer-arbitrum-sepolia]: https://thegraph.com/explorer/subgraphs/BZYXgTYGe51dy5rW6LhrLN7PWSiAgRQoqSBJEiPpRN9K
[v2-studio-arbitrum-sepolia]: https://api.studio.thegraph.com/query/57079/sablier-v2-arbitrum-sepolia/version/latest

{/* Chain: Avalanche */}

[v2-network-avalanche]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/FdVwZuMV43yCb1nPmjnLQwmzS58wvKuLMPzcZ4UWgWAc
[v2-explorer-avalanche]: https://thegraph.com/explorer/subgraphs/FdVwZuMV43yCb1nPmjnLQwmzS58wvKuLMPzcZ4UWgWAc
[v2-studio-avalanche]: https://api.studio.thegraph.com/query/57079/sablier-v2-avalanche/version/latest

{/* Chain: Base */}

[v2-network-base]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/3pxjsW9rbDjmZpoQWzc5CAo4vzcyYE9YQyTghntmnb1K
[v2-explorer-base]: https://thegraph.com/explorer/subgraphs/3pxjsW9rbDjmZpoQWzc5CAo4vzcyYE9YQyTghntmnb1K
[v2-studio-base]: https://api.studio.thegraph.com/query/57079/sablier-v2-base/version/latest

{/* Chain: Blast */}

[v2-network-blast]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/BXoC2ToMZXnTmCjWftQRPh9zMyM7ysijMN54Nxzb2CEY
[v2-explorer-blast]: https://thegraph.com/explorer/subgraphs/BXoC2ToMZXnTmCjWftQRPh9zMyM7ysijMN54Nxzb2CEY
[v2-studio-blast]: https://api.studio.thegraph.com/query/57079/sablier-v2-blast/version/latest

{/* Chain: BSC */}

[v2-network-bsc]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/BVyi15zcH5eUg5PPKfRDDesezMezh6cAkn8LPvh7MVAF
[v2-explorer-bsc]: https://thegraph.com/explorer/subgraphs/BVyi15zcH5eUg5PPKfRDDesezMezh6cAkn8LPvh7MVAF
[v2-studio-bsc]: https://api.studio.thegraph.com/query/57079/sablier-v2-bsc/version/latest

{/* Chain: Chiliz */}

[v2-network-chiliz]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/HKvzAuGjrEiza11W48waJy5csbhKpkMLF688arwHhT5f
[v2-explorer-chiliz]: https://thegraph.com/explorer/subgraphs/HKvzAuGjrEiza11W48waJy5csbhKpkMLF688arwHhT5f
[v2-studio-chiliz]: https://api.studio.thegraph.com/query/57079/sablier-v2-chiliz/version/latest

{/* Chain: Gnosis */}

[v2-network-gnosis]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/EXhNLbhCbsewJPx4jx5tutNXpxwdgng2kmX1J7w1bFyu
[v2-explorer-gnosis]: https://thegraph.com/explorer/subgraphs/EXhNLbhCbsewJPx4jx5tutNXpxwdgng2kmX1J7w1bFyu
[v2-studio-gnosis]: https://api.studio.thegraph.com/query/57079/sablier-v2-gnosis/version/latest

{/* Chain: Lightlink */}

[v2-explorer-lightlink]: https://graph.phoenix.lightlink.io/query/subgraphs/name/lightlink/sablier-v2-lightlink/graphql
[v2-custom-lightlink]: https://graph.phoenix.lightlink.io/query/subgraphs/name/lightlink/sablier-v2-lightlink

{/* Chain: Mainnet | Ethereum */}

[v2-explorer-ethereum]: https://thegraph.com/explorer/subgraphs/EuZZnhFtdCGqN2Zt7EMGYDqQKNrVuhJL63KAfwvF35bL
[v2-studio-ethereum]: https://api.studio.thegraph.com/query/57079/sablier-v2/version/latest
[v2-network-ethereum]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/EuZZnhFtdCGqN2Zt7EMGYDqQKNrVuhJL63KAfwvF35bL

{/* Chain: Optimism */}

[v2-network-optimism]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/6e6Dvs1yDpsWDDREZRqxGi54SVdvTNzUdKpKJxniKVrp
[v2-explorer-optimism]: https://thegraph.com/explorer/subgraphs/6e6Dvs1yDpsWDDREZRqxGi54SVdvTNzUdKpKJxniKVrp
[v2-studio-optimism]: https://api.studio.thegraph.com/query/57079/sablier-v2-optimism/version/latest

{/* Chain: Optimism Sepolia */}

[v2-network-optimism-sepolia]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/2a2JpbmBfQs78UEvQYXgweHetcZUPm9zXCjP69o5mTed
[v2-explorer-optimism-sepolia]: https://thegraph.com/explorer/subgraphs/2a2JpbmBfQs78UEvQYXgweHetcZUPm9zXCjP69o5mTed
[v2-studio-optimism-sepolia]: https://api.studio.thegraph.com/query/57079/sablier-v2-optimism-sepolia/version/latest

{/* Chain: Polygon */}

[v2-network-polygon]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/CsDNYv9XPUMP8vufuwDVKQrVhsxhzzRHezjLFFKZZbrx
[v2-explorer-polygon]: https://thegraph.com/explorer/subgraphs/CsDNYv9XPUMP8vufuwDVKQrVhsxhzzRHezjLFFKZZbrx
[v2-studio-polygon]: https://api.studio.thegraph.com/query/57079/sablier-v2-polygon/version/latest

{/* Chain: Scroll */}

[v2-network-scroll]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/HVcngokCByfveLwguuafrBC34xB65Ne6tpGrXHmqDSrh
[v2-explorer-scroll]: https://thegraph.com/explorer/subgraphs/HVcngokCByfveLwguuafrBC34xB65Ne6tpGrXHmqDSrh
[v2-studio-scroll]: https://api.studio.thegraph.com/query/57079/sablier-v2-scroll/version/latest

{/* Chain: Ethereum Sepolia */}

[v2-network-sepolia]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/3JR9ixhdUxX5oc2Yjr6jkG4XUqDd4guy8niL6AYzDKss
[v2-explorer-sepolia]: https://thegraph.com/explorer/subgraphs/3JR9ixhdUxX5oc2Yjr6jkG4XUqDd4guy8niL6AYzDKss
[v2-studio-sepolia]: https://api.studio.thegraph.com/query/57079/sablier-v2-sepolia/version/latest

{/* Chain: zkSync */}

[v2-network-zksync]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/GY2fGozmfZiZ3xF2MfevohLR4YGnyxGxAyxzi9zmU5bY
[v2-explorer-zksync]: https://thegraph.com/explorer/subgraphs/GY2fGozmfZiZ3xF2MfevohLR4YGnyxGxAyxzi9zmU5bY
[v2-studio-zksync]: https://api.studio.thegraph.com/query/57079/sablier-v2-zksync/version/latest

{/* --------------------------------------------------------------------------------------------------------------------------------- */}

[endpoint-lockup]: https://indexer.hyperindex.xyz/53b7e25/v1/graphql

{/* --------------------------------------------------------------------------------------------------------------------------------- */}
{/* --------------------------------------------------------------------------------------------------------------------------------- */}
{/* --------------------------------------------------------------------------------------------------------------------------------- */}

================
File: docs/api/03-airdrops/02-merkle-api/01-overview.mdx
================
---
id: "overview"
sidebar_position: 1
title: "Overview"
---

import LinkPreviewMerkleAPI from "@site/src/components/molecules/link-previews/MerkleAPI";

Sablier's Airdrops rely on pre-configured Merkle trees. This data structure contains the list of recipients as well as
their individual claim details.

### General data flow

Trees allow us to store minimal data at the contract level, while being able to cryptographically prove someone is
entitled to claim from the contract, using proofs generated with a separate off-chain dataset (and the onchain root).

The root hash of the tree will be stored inside the deployed Airstream contract. The tree itself, as well as the initial
list will be stored in an IPFS file.

Any action such as checking for eligibility or requesting the claim details of a certain user will involve reading from
the IPFS file, generating proofs based on the Merkle tree and interacting with the contract using the data obtained
previously.

### Open-source solution

To make this functionality available to both Sablier client interfaces and 3rd party integrators we've created a Rust
backend service called `merkle-api`. Through a REST API, it provides access to creating, storing and reading from
Airstream related Merkle trees.

#### Integrations

To integrate this API into your own applications, feel free to use the official endpoints or fork the repository and run
the backend in your own environment. We're keen to improve and optimize this service, so any suggestions or issues can
be flagged directly in the Github repository.

<LinkPreviewMerkleAPI />

================
File: docs/api/03-airdrops/02-merkle-api/02-functionality.mdx
================
---
id: "functionality"
sidebar_position: 2
title: "Functionality"
---

import LinkPreview from "@site/src/components/molecules/LinkPreview";

## Architecture

The backend is written in Rust. It can run locally (or in a self-hosted environment) with
[`warp`](https://github.com/seanmonstar/warp) as well as using Vercel with its
[`rust runtime`](https://github.com/vercel-community/rust).

You can integrate the backend functionality using the official endpoints (below) but we recommend running it in a
self-hosted environment for improved reliability (meaning you can fork and provide your own IPFS and Pinata access
keys).

Feel free to reach out for any guidance or feedback.

The official endpoints can be seen in the [Airdrops Indexers](/api/airdrops/indexers) section.

## Create: `/api/create`

Call this route to create a new Merkle/Airstream campaign.

### Prerequisites

Before creating a new campaign, you'll need:

- The `decimals` of the asset you're basing the campaign upon
- A CSV file including a list of `[address, amount]` for every campaign recipient

You can download a template for the CSV file from the link below or preview it
[here](https://github.com/sablier-labs/sablier-labs.github.io/blob/1933e3b5176c93b236d9a483683dad3a282cc39a/templates/airstream-template.csv).

<LinkPreview
  href="https://files.sablier.com/templates/airstream-template.csv"
  icon="github"
  subtitle="airstream-template.csv"
  title="Sablier Template for Airstreams (CSV)"
/>

:::tip

The CSV will contain a header row, followed by pairs of addresses and amounts. The amounts will be in humanized form, as
the API deals with the padding of each value (with the decimals of the token) on its own.

:::

### Description

|                  |                                                                                                                          |
| :--------------- | ------------------------------------------------------------------------------------------------------------------------ |
| **Endpoint**     | `/api/create`                                                                                                            |
| **Method**       | `POST`                                                                                                                   |
| **Query Params** | `{decimals: number}`                                                                                                     |
| **Body**         | `FormData` on `{data: File}`                                                                                             |
| **Response**     | See in [Rust](https://github.com/sablier-labs/merkle-api/blob/main/src/data_objects/response.rs#L22) Overview TS (below) |

```typescript
type Response = {
  /** IPFS content identifier for the uploaded file */
  cid: string;
  /** Expected number of recipients */
  recipients: string;
  /** HEX root fo the Merkle tree */
  root: string;
  /** Humanized status */
  status: string;
  /** Expected amount of assets required by the campaign */
  total: string;
};
```

### Functionality

The `/api/create` route will perform the following actions:

**1. Validation and processing**

- Validate the CSV file and its contents
- Add decimal padding to every amount
- Build the Merkle tree and generate a root hash
- Compute intermediary data (e.g. total expected amount, number of recipients)
- Prepare an object containing the list, the tree and the data above

**2. Upload to IPFS**

- Upload the object in a JSON file on IPFS
- Get a hold of the IPFS CID (unique identifier of the uploaded file)

**3. Return data to client**

- Return the root hash, IPFS CID and intermediary data points to the client
- [Next] The client will use all these to call the factory and deploy a new campaign

### Code

For more insight, check out the implementation details.

<LinkPreview
  href="https://github.com/sablier-labs/merkle-api/blob/main/src/controller/create.rs"
  icon="github"
  subtitle="Github - sablier-labs/merkle-api"
  title="create.rs"
/>

---

## Eligibility: `/api/eligibility`

Call this route to check if a recipient is eligible to claim a stream from the Merkle/Airstream campaign.

:::info

This endpoint uses an authentication scheme. Please reach out if you need to use our deployed endpoints in your app.

:::

### Prerequisites

To check eligibility for an address, you'll be required to provide:

- the address of the user
- the CID of the IPFS file (see the [create](/api/airdrops/merkle-api/functionality#create-apicreate) flow above for
  context) the campaign is linked to

To get a hold of the second item you can see some options here in the
[Common flows](/api/airdrops/merkle-api/examples#get-a-campaigns-cid) page.

### Description

|                  |                                                                                                                          |
| :--------------- | ------------------------------------------------------------------------------------------------------------------------ |
| **Endpoint**     | `/api/eligibility`                                                                                                       |
| **Method**       | `GET`                                                                                                                    |
| **Query Params** | `{address: string, cid: string}`                                                                                         |
| **Response**     | See in [Rust](https://github.com/sablier-labs/merkle-api/blob/main/src/data_objects/response.rs#L32) Overview TS (below) |

```typescript
type Response = {
  /** Address of the requested recipient */
  address: IAddress;
  /** Amount the recipient is eligible for */
  amount: string;
  /** Position of the recipient in the list */
  index: 0;
  /** Merkle proof */
  proof: string[];
};
```

### Functionality

The `/api/eligibility` route will perform the following actions:

1. Retrieve the campaign's IPFS file and extract the recipient's list and Merkle tree
2. Search for the provided wallet address

### Code

For more insight, check out the implementation details.

<LinkPreview
  href="https://github.com/sablier-labs/merkle-api/blob/main/src/controller/eligibility.rs"
  icon="github"
  subtitle="Github - sablier-labs/merkle-api"
  title="eligibility.rs"
/>

---

## Eligibility: `/api/validity`

Call this route to check if an IPFS CID links to a valid Merkle/Airstream campaign file. Given users may create
campaigns by passing invalid IPFS CIDs (by mistake), we use this route to perform some minor sanity checks before
allowing admins to pursue the creation of a campaign in the UI.

### Prerequisites

To check eligibility for an address, you'll be required to provide:

- the CID of the IPFS file the campaign is linked to

To get a hold of it you can see some options here in the
[Common flows](/api/airdrops/merkle-api/examples#get-a-campaigns-cid) page.

### Description

|                  |                                                                                                                          |
| :--------------- | ------------------------------------------------------------------------------------------------------------------------ |
| **Endpoint**     | `/api/validity`                                                                                                          |
| **Method**       | `GET`                                                                                                                    |
| **Query Params** | `{cid: string}`                                                                                                          |
| **Response**     | See in [Rust](https://github.com/sablier-labs/merkle-api/blob/main/src/data_objects/response.rs#L41) Overview TS (below) |

```typescript
type Response = {
  /** IPFS content identifier for the uploaded file */
  cid: string;
  /** Expected number of recipients */
  recipients: string;
  /** HEX root fo the Merkle tree */
  root: string;
  /** Expected amount of assets required by the campaign */
  total: string;
};
```

### Functionality

The `/api/validity` route will perform the following actions:

1. Retrieve the campaign's IPFS file
2. Run some sanity checks on the file contents

### Code

For more insight, check out the implementation details.

<LinkPreview
  href="https://github.com/sablier-labs/merkle-api/blob/main/src/controller/validity.rs"
  icon="github"
  subtitle="Github - sablier-labs/merkle-api"
  title="validity.rs"
/>

================
File: docs/api/03-airdrops/02-merkle-api/03-examples.mdx
================
---
id: "examples"
sidebar_position: 3
title: "Examples"
---

import TabItem from "@theme/TabItem";
import Tabs from "@theme/Tabs";

# Examples of common flows

Here are some common architectural flows you may need to integrate into your application. These include ways to gather
the prerequisite data necessary for each backend [functionality](/api/airdrops/merkle-api/functionality) described
earlier.

## Get a campaign's CID

To get a hold of a campaign's IPFS CID, you can:

<ol type="A">
  <li>
    Check the [create](/reference/airdrops/contracts/interfaces/interface.ISablierMerkleFactory#events) events emitted
    by the Merkle factory
  </li>
  <li>Use the Sablier [indexers](/api/overview) to query for that particular piece of information.</li>
</ol>

For approach "B", run the following query against the official endpoints:

<Tabs>
  <TabItem value="TheGraph" label="The Graph" default>
 ```GraphQL title:Example of a query for campaign data using The Graph's subgraphs
    query getCampaignData($campaignId: String!){
      campaign(id: $campaignId){
        id
        lockup
        root
        //highlight-start
        ipfsCID
        //highlight-end
        aggregateAmount
        totalRecipients
      }
    }
```
  </TabItem>
  <TabItem value="Envio" label="Envio">
 ```GraphQL title:Example of a query for campaign data using Envio's indexers
    query getCampaignData($campaignId: String!){
      Campaign(where: {id: {_eq: $campaignId}} ){
        id
        lockup
        root
        //highlight-start
        ipfsCID
        //highlight-end
        aggregateAmount
        totalRecipients
      }
    }
```
  </TabItem>
</Tabs>

## Check eligibility for an address

To check if an address is eligible, you'll have to use the [/api/eligibility](functionality#eligibility-apieligibility)
route provided by the merkle-api backend.

#### Steps

1. Get the campaign CID (see [the example](examples#get-a-campaigns-cid) above)
2. Call the`/api/eligibility` route using the CID and the wallet address

Please read more on the dedicated route documentation within the
[/api/eligibility](functionality#eligibility-apieligibility) section of the functionality page.

As an alternative, you can also check the eligibility of an address (and bypass the backend) by simply searching for
that address in the list stored within the IPFS file from step 1. You'll still have to download the file first, using
its CID.

## Get the tokenId after a claim

After someone claims, you may want to show them a preview of the stream (or its NFT). To do that, you'll have to get a
hold of the `tokenId` (or `streamId`) related to that user's claim.

To get a hold of a `tokenId` linked to a claim you can:

<ol type="A">
  <li>
    Listen to the [claim](/reference/airdrops/contracts/interfaces/interface.ISablierMerkleLL#claim) method and the
    Claim event emitted by the Merkle contract instance
  </li>
  <li>Use the [Sablier Indexers](/api/overview) to query for that particular piece of information.</li>
</ol>

For approach "B", run the following query against the official endpoints (make sure the address is lowercased):

<Tabs>
  <TabItem value="TheGraph" label="The Graph" default>
 ```GraphQL title:Example of a query for claim data using The Graph's subgraphs
    query getClaimForRecipient($campaignId: String!, $recipient: String){
      actions(where: {campaign: $campaignId, category: Claim, claimRecipient: $recipient }){
        campaign{
          id
          lockup
        }
        claimTokenId
        claimRecipient
        claimIndex
      }
    }
```
  </TabItem>
  <TabItem value="Envio" label="Envio">
 ```GraphQL title:Example of a query for claim data using Envio's indexers
      query getClaimForRecipient($campaignId: String!, $recipient: String){
      Action(where: {
        _and: [
          {campaign: {_eq: $campaignId}}
          {category: {_eq: Claim}}
          {claimRecipient: {_eq: $recipient}}
        ]
      }){
        campaignObject{
          id
          lockup
        }
        claimTokenId
        claimRecipient
        claimIndex
      }
    }
```
  </TabItem>
</Tabs>

#### Bonus: Stream NFT

To get the Stream NFT, using the same query as in option "B", retrieve the `lockup` contract (where the Stream NFT is
issued) and its `tokenId`. With them you can call the
[`tokenURI`](/reference/lockup/contracts/contract.LockupNFTDescriptor#tokenuri) method, which will return the SVG code
of the onchain NFT.

:::note Extract the SVG tags

The actual SVG tags are encoded inside the response of the `tokenURI` method. You can feed this blob to an HTML `img`
tag or choose to render the SVG tags themselves. To get a hold of this code in plain format (not in `base64`) you could
run the following Javascript code which decodes the response and

```typescript
const toPart = output.split("data:application/json;base64,").pop();
const toString = Buffer.from(toPart || "", "base64").toString("utf-8");
const toJSON = JSON.parse(toString);

const blob = _.get(toJSON, "image")?.split("data:image/svg+xml;base64,")[1];
const toSVG = Buffer.from(blob || "", "base64").toString("utf-8");
```

:::

## Check if a user claimed their stream

To check if a user has already claimed their stream from a campaign you can:

<ol type="A">
  <li>
    Call the [`hasClaimed`](/reference/airdrops/contracts/interfaces/interface.ISablierMerkleBase#hasclaimed) method
    form the Merkle contract instance
  </li>
  <li>Use the [Sablier Indexers](/api/overview) to query for that particular piece of information.</li>
</ol>

#### Approach A

For approach "A" you'll need to perform the following actions:

1. Get a hold of the campaign's CID, Lockup contract address, and user address (for the first items, see the
   [Get a campaign's CID](/api/airdrops/merkle-api/examples#get-a-campaigns-cid) example above)
2. Check the eligibility of a user (see
   [Eligibility](/api/airdrops/merkle-api/examples#check-eligibility-for-an-address) example above) and extract their
   `index`
3. Call the `hasClaimed` method inside the `lockup` contract using the `index` retrieved at step 2

:::note

The index of a particular user represents their assigned order number in the eligibility list. We use this value to
generate a proof in case the recipient is eligible and to register their claim directly inside the contract.

:::

#### Approach B

For approach "B", run the same query as in the
[Get the tokenId after a claim](/api/airdrops/merkle-api/examples#get-the-tokenid-after-a-claim) example. If the query
yields any results, that means the user has claimed their stream.

:::tip

A missing claim could also mean the user wasn't eligible in the first place. We recommend checking for eligibility
alongside any existing claim checks.

:::

================
File: docs/api/03-airdrops/03-the-graph/01-entities.mdx
================
---
draft: true
id: "entities"
sidebar_position: 1
title: "Entities"
---

:::info

For an introduction into the Sablier primitives and our architectural choices, check out the
[Lockup subgraph](/api/lockup/the-graph/entities) before reading about the Merkle subgraph.

:::

## Entity Architecture

Inside the **Merkle** subgraph, the `schema.graphql` file is responsible of defining the following Sablier entities:

### Primary

| Entity   | Description                                                                                                    |
| -------- | -------------------------------------------------------------------------------------------------------------- |
| Factory  | Instances of `MerkleLockupFactory`                                                                             |
| Campaign | Instances of `SablierMerkleLL`, the primary entity tracking the up to date state of an Airdrop/Merkle campaign |
| Action   | Emitted events transformed into historical entries (e.g. Claim, Create, Clawback)                              |
| Activity | An entity tracking daily usage (one item per day) for each campaign (e.g. amount claimed per day)              |
| Asset    | The ERC20 asset that is being streamed                                                                         |

### Secondary

| Entity  | Description                                                                                   |
| ------- | --------------------------------------------------------------------------------------------- |
| Watcher | A singleton data store for subgraph-level unique indexes such as the campaign or action index |

## Structure

The structure of these entities is built on the same rules and mindset which was applied on the
[lockup entities](/api/lockup/the-graph/entities).

### Identifying

Airstreams will be assigned a unique `contract address` once they are deployed by the Merkle Factory. While this makes
it easy to identify items at the contract level, we need to consider the following for both subgraphs and client
interfaces:

- items should be uniquely identifiable across multiple chains
- items should be identifiable with short, easy to digest names

To address the first observation, the subgraph uses the following identifier for an Airstream.

| Type           | Description                                                                                 | Example                         |
| -------------- | ------------------------------------------------------------------------------------------- | ------------------------------- |
| `Airstream.id` | A self-explanatory structure built using the following structure: `contractAddress-chainId` | <nobr>`0xAB..12-1115511`</nobr> |

The example from the table above translates to: **_a stream on Ethereum Sepolia (chain id `1115511`), with the contract
address `0xAB..12`_**.

:::info

We've chosen not to apply aliases to Airstreams for now. In the future, we may ask the campaign creator to provide a
name or an alias to be used in the URL.

:::

## Architecture and Data Flow

The data flow applied to this subgraph is identical to the one used in the
[lockup subgraph](/api/lockup/the-graph/architecture).

================
File: docs/api/03-airdrops/04-envio/01-similarities.mdx
================
---
draft: true
id: "similarities"
sidebar_position: 1
title: "Similarities"
---

# Similarities

Envio indexers are designed to mirror the functionality and structure of the The Graph subgraphs.

For an introduction into the Sablier primitives and our architectural choices, check out the
[Merkle subgraph](/api/airdrops/the-graph/entities) before reading about the `merkle-envio` indexer.

Similar entities are used between The Graph and Envio setups, as well as between the Lockup and Merkle deployments.

- [Entities](/api/airdrops/the-graph/entities)

================
File: docs/api/03-airdrops/01-indexers.mdx
================
---
id: "indexers"
sidebar_position: 1
title: "Indexers"
---

import TableEnvio from "@site/src/autogen/lockup/TableEnvio.mdx";
import TableTheGraph from "@site/src/autogen/lockup/TableTheGraph.mdx";
import LinkPreviewIndexers from "@site/src/components/molecules/link-previews/Indexers";
import ExplainerEnvio from "@site/src/snippets/ExplainerEnvio.mdx";
import ExplainerTheGraph from "@site/src/snippets/ExplainerTheGraph.mdx";

# Sablier Airdrops

This page documents the indexers for the [Sablier Airdrops](/concepts/airdrops/overview) protocol, which powers the [Airdrops](/apps/features/airdrops) product in the Sablier Interface.

:::info

Vested airdrops will create a [Lockup](/concepts/lockup/overview) stream when a user makes a claim.

:::

## Envio

### Source Code

<LinkPreviewIndexers vendor="envio" protocol="airdrops" />

### Endpoints

<ExplainerEnvio />

#### Table

<TableEnvio />

## The Graph

### Source Code

<LinkPreviewIndexers vendor="graph" protocol="airdrops" />

### Endpoints

<ExplainerTheGraph />

<TableTheGraph />

================
File: docs/api/03-airdrops/05-previous-indexers.mdx
================
---
id: "previous-indexers"
sidebar_position: 5
title: "Previous Indexers"
---

import DeprecatedIndexers from "@site/src/snippets/DeprecatedIndexers.mdx";

<DeprecatedIndexers />

| Chain            | Explorer                                                          | Studio[^2]                              | Decentralized Network[^1]                  |
| ---------------- | ----------------------------------------------------------------- | --------------------------------------- | ------------------------------------------ |
| Ethereum         | [sablier-v2-ms][v2-explorer-ms-ethereum]                          | [Studio][v2-studio-ms-ethereum]         | [Network][v2-network-ms-ethereum]          |
| Arbitrum         | [sablier-v2-ms-arbitrum][v2-explorer-ms-arbitrum]                 | [Studio][v2-studio-ms-arbitrum]         | [Network][v2-network-ms-arbitrum]          |
| Arbitrum Sepolia | [sablier-v2-ms-arbitrum-sepolia][v2-explorer-ms-arbitrum-sepolia] | [Studio][v2-studio-ms-arbitrum-sepolia] | [Network][v2-network-ms-arbitrum-sepolia]  |
| Avalanche        | [sablier-v2-ms-avalanche][v2-explorer-ms-avalanche]               | [Studio][v2-studio-ms-avalanche]        | [Network][v2-network-ms-avalanche]         |
| Base             | [sablier-v2-ms-base][v2-explorer-ms-base]                         | [Studio][v2-studio-ms-base]             | [Network][v2-network-ms-base]              |
| Blast            | [sablier-v2-ms-blast][v2-explorer-ms-blast]                       | [Studio][v2-studio-ms-blast]            | [Network][v2-network-ms-blast]             |
| BNB Chain        | [sablier-v2-ms-bsc][v2-explorer-ms-bsc]                           | [Studio][v2-studio-ms-bsc]              | [Network][v2-network-ms-bsc]               |
| Chiliz Chain     | [sablier-v2-ms-chiliz][v2-explorer-ms-chiliz]                     | [Studio][v2-studio-ms-chiliz]           | [Network][v2-network-ms-chiliz]            |
| Ethereum Sepolia | [sablier-v2-ms-sepolia][v2-explorer-ms-sepolia]                   | [Studio][v2-studio-ms-sepolia]          | [Network][v2-network-ms-sepolia]           |
| Gnosis           | [sablier-v2-ms-gnosis][v2-explorer-ms-gnosis]                     | [Studio][v2-studio-ms-gnosis]           | [Network][v2-network-ms-gnosis]            |
| Lightlink        | [sablier-v2-ms-lightlink\*][v2-explorer-ms-lightlink]             | N/A                                     | [Lightlink Node\*][v2-custom-ms-lightlink] |
| Optimism         | [sablier-v2-ms-optimism][v2-explorer-ms-optimism]                 | [Studio][v2-studio-ms-optimism]         | [Network][v2-network-ms-optimism]          |
| Optimism Sepolia | [sablier-v2-ms-optimism-sepolia][v2-explorer-ms-optimism-sepolia] | [Studio][v2-studio-ms-optimism-sepolia] | [Network][v2-network-ms-optimism-sepolia]  |
| Polygon          | [sablier-v2-ms-polygon][v2-explorer-ms-polygon]                   | [Studio][v2-studio-ms-polygon]          | [Network][v2-network-ms-polygon]           |
| Scroll           | [sablier-v2-ms-scroll][v2-explorer-ms-scroll]                     | [Studio][v2-studio-ms-scroll]           | [Network][v2-network-ms-scroll]            |
| zkSync           | [sablier-v2-ms-zksync][v2-explorer-ms-zksync]                     | [Studio][v2-studio-ms-zksync]           | [Network][v2-network-ms-zksync]            |

{/* --------------------------------------------------------------------------------------------------------------------------------- */}
{/* --------------------------------------------------------------------------------------------------------------------------------- */}
{/* --------------------------------------------------------------------------------------------------------------------------------- */}

{/* Chain: Arbitrum */}

[v2-network-ms-arbitrum]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/CPCMKbUFEM8CzVbfic1y34qKbTrKADX9Du9QxsAMAwqU
[v2-explorer-ms-arbitrum]: https://thegraph.com/explorer/subgraphs/CPCMKbUFEM8CzVbfic1y34qKbTrKADX9Du9QxsAMAwqU
[v2-studio-ms-arbitrum]: https://api.studio.thegraph.com/query/57079/sablier-v2-ms-arbitrum/version/latest

{/* Chain: Arbitrum Sepolia */}

[v2-network-ms-arbitrum-sepolia]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/BBJgy9RANbViGedeWTrVpH2bwm22E3niEzWcqHPMGtna
[v2-explorer-ms-arbitrum-sepolia]: https://thegraph.com/explorer/subgraphs/BBJgy9RANbViGedeWTrVpH2bwm22E3niEzWcqHPMGtna
[v2-studio-ms-arbitrum-sepolia]: https://api.studio.thegraph.com/query/57079/sablier-v2-ms-arbitrum-sepolia/version/latest

{/* Chain: Avalanche */}

[v2-network-ms-avalanche]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/2beDuAvmwbyFzJ95HAwfqNjnYT6nEnzbEfSNhfWGMyhJ
[v2-explorer-ms-avalanche]: https://thegraph.com/explorer/subgraphs/2beDuAvmwbyFzJ95HAwfqNjnYT6nEnzbEfSNhfWGMyhJ
[v2-studio-ms-avalanche]: https://api.studio.thegraph.com/query/57079/sablier-v2-ms-avalanche/version/latest

{/* Chain: Base */}

[v2-network-ms-base]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/DrfN5cbvcCmpQUSc5RE9T1UxtcnMREi1Rd2PgLzDZCo3
[v2-explorer-ms-base]: https://thegraph.com/explorer/subgraphs/DrfN5cbvcCmpQUSc5RE9T1UxtcnMREi1Rd2PgLzDZCo3
[v2-studio-ms-base]: https://api.studio.thegraph.com/query/57079/sablier-v2-ms-base/version/latest

{/* Chain: Blast */}

[v2-network-ms-blast]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/HVqkPvCRAvbxjx6YVmkk6w6rHPrqqtiymcGiQiMKPw8f
[v2-explorer-ms-blast]: https://thegraph.com/explorer/subgraphs/HVqkPvCRAvbxjx6YVmkk6w6rHPrqqtiymcGiQiMKPw8f
[v2-studio-ms-blast]: https://api.studio.thegraph.com/query/57079/sablier-v2-ms-blast/version/latest

{/* Chain: BSC */}

[v2-network-ms-bsc]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/8uU9qAw9fSzdjqebymGRXWCjtZ5DQCmUA6QzRA14ARpz
[v2-explorer-ms-bsc]: https://thegraph.com/explorer/subgraphs/8uU9qAw9fSzdjqebymGRXWCjtZ5DQCmUA6QzRA14ARpz
[v2-studio-ms-bsc]: https://api.studio.thegraph.com/query/57079/sablier-v2-ms-bsc/version/latest

{/* Chain: Chiliz */}

[v2-network-ms-chiliz]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/DdhRyXwhvEmKyioCk41m6Xu9fyaprsnp4gMWZ3bHYZJd
[v2-explorer-ms-chiliz]: https://thegraph.com/explorer/subgraphs/DdhRyXwhvEmKyioCk41m6Xu9fyaprsnp4gMWZ3bHYZJd
[v2-studio-ms-chiliz]: https://api.studio.thegraph.com/query/57079/sablier-v2-ms-chiliz/version/latest

{/* Chain: Ethereum Sepolia */}

[v2-network-ms-sepolia]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/8UVeHt7rHA27XZhViugaW4nStiN332dHTDWVTNBLCqPc
[v2-explorer-ms-sepolia]: https://thegraph.com/explorer/subgraphs/8UVeHt7rHA27XZhViugaW4nStiN332dHTDWVTNBLCqPc
[v2-studio-ms-sepolia]: https://api.studio.thegraph.com/query/57079/sablier-v2-ms-sepolia/version/latest

{/* Chain: Gnosis */}

[v2-network-ms-gnosis]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/FViBHgu2TtaZZXspDBzACjuPYKtqVDysmH35pk3W3zJJ
[v2-explorer-ms-gnosis]: https://thegraph.com/explorer/subgraphs/FViBHgu2TtaZZXspDBzACjuPYKtqVDysmH35pk3W3zJJ
[v2-studio-ms-gnosis]: https://api.studio.thegraph.com/query/57079/sablier-v2-ms-gnosis/version/latest

{/* Chain: Lightlink */}

[v2-explorer-ms-lightlink]: https://graph.phoenix.lightlink.io/query/subgraphs/name/lightlink/sablier-v2-ms-lightlink/graphql
[v2-custom-ms-lightlink]: https://graph.phoenix.lightlink.io/query/subgraphs/name/lightlink/sablier-v2-ms-lightlink

{/* Chain: Mainnet | Ethereum */}

[v2-explorer-ms-ethereum]: https://thegraph.com/explorer/subgraphs/FigCYTmdPtXbf4tgNiy5ZrtnYefz92hsMcwM4f9N5ZeZ
[v2-studio-ms-ethereum]: https://api.studio.thegraph.com/query/57079/sablier-v2-ms/version/latest
[v2-network-ms-ethereum]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/FigCYTmdPtXbf4tgNiy5ZrtnYefz92hsMcwM4f9N5ZeZ

{/* Chain: Optimism */}

[v2-network-ms-optimism]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/7iSmF69W4mQqtx6EfWXXn5s27Hrdh72etsPKVC9iE62U
[v2-explorer-ms-optimism]: https://thegraph.com/explorer/subgraphs/7iSmF69W4mQqtx6EfWXXn5s27Hrdh72etsPKVC9iE62U
[v2-studio-ms-optimism]: https://api.studio.thegraph.com/query/57079/sablier-v2-ms-optimism/version/latest

{/* Chain: Optimism Sepolia */}

[v2-network-ms-optimism-sepolia]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/CG5QddHKoABuN6KHZHYTHL7upg2iPTMYxi35Ey7jspkX
[v2-explorer-ms-optimism-sepolia]: https://thegraph.com/explorer/subgraphs/CG5QddHKoABuN6KHZHYTHL7upg2iPTMYxi35Ey7jspkX
[v2-studio-ms-optimism-sepolia]: https://api.studio.thegraph.com/query/57079/sablier-v2-ms-optimism-sepolia/version/latest

{/* Chain: Polygon */}

[v2-network-ms-polygon]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/4r2pC3iyLbzytNa5phat3SWdMEyXG8fmnf1K89D7zP2G
[v2-explorer-ms-polygon]: https://thegraph.com/explorer/subgraphs/4r2pC3iyLbzytNa5phat3SWdMEyXG8fmnf1K89D7zP2G
[v2-studio-ms-polygon]: https://api.studio.thegraph.com/query/57079/sablier-v2-ms-polygon/version/latest

{/* Chain: Scroll */}

[v2-network-ms-scroll]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/F1QnrgBpsVKtiVzkLisEC2PDo6cjzLoAy5HhPdFRdjW
[v2-explorer-ms-scroll]: https://thegraph.com/explorer/subgraphs/F1QnrgBpsVKtiVzkLisEC2PDo6cjzLoAy5HhPdFRdjW
[v2-studio-ms-scroll]: https://api.studio.thegraph.com/query/57079/sablier-v2-ms-scroll/version/latest

{/* Chain: zkSync */}

[v2-network-ms-zksync]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/BboiKY7JCdznoqurdXRizL9UYD1YdQKajaj4gvUrPPEA
[v2-explorer-ms-zksync]: https://thegraph.com/explorer/subgraphs/BboiKY7JCdznoqurdXRizL9UYD1YdQKajaj4gvUrPPEA
[v2-studio-ms-zksync]: https://api.studio.thegraph.com/query/57079/sablier-v2-ms-zksync/version/latest

{/* --------------------------------------------------------------------------------------------------------------------------------- */}

[endpoint-merkle]: https://indexer.hyperindex.xyz/508d217/v1/graphql

{/* --------------------------------------------------------------------------------------------------------------------------------- */}
{/* --------------------------------------------------------------------------------------------------------------------------------- */}
{/* --------------------------------------------------------------------------------------------------------------------------------- */}

================
File: docs/api/04-flow/02-the-graph/01-entities.mdx
================
---
id: "entities"
sidebar_position: 1
title: "Entities"
---

## Entity Architecture

GraphQL entities defined by the Sablier subgraphs are meant to mirror the functionality exposed by our core flow
contracts. To achieve this, events are stored as historical entries (e.g. Action) while also being used to mutate
attributes for live entities (e.g. Stream).

Inside the **flow** subgraph, the `schema.graphhql` file is responsible of
defining the following Sablier entities:

### Primary

| Entity | Description                                                                                 |
| ------ | ------------------------------------------------------------------------------------------- |
| Action | Emitted events transformed into historical entries (e.g. Create, Withdraw, Adjust, Deposit) |
| Stream | Primary entity tracking the up to date state of a stream                                    |
| Asset  | The ERC20 asset that is being streamed                                                      |

### Secondary

| Entity  | Description                                                                                                               |
| ------- | ------------------------------------------------------------------------------------------------------------------------- |
| Batch   | An entity grouping a set of stream created all at once (action done through the batch interface of SablierFlow contracts) |
| Batcher | An entity resolving 1:1 to a stream sender, in charge of managing the count of "batches" of streams one creates           |
| Watcher | A singleton data store for subgraph-level unique indexes such as the stream or action index                               |

================
File: docs/api/04-flow/02-the-graph/02-structure.mdx
================
---
id: "structure"
sidebar_position: 2
title: "Structure"
---

We'll break down the schema into primary and secondary entities.

| Type      | Entities                |
| --------- | ----------------------- |
| Primary   | Action, Stream, Asset   |
| Secondary | Batch, Batcher, Watcher |

---

## Action

Events emitted by the Sablier Flow contracts will:

1. Be used to mutate the data stored in the individual `Stream` entities
2. Be stored as historical logs (list of `Action`) to show the evolution of a related stream

Based on the schema defined `ActionCategory`, the following actions will be tracked by the subgraph:

| Action         | Contract Events        |
| -------------- | ---------------------- |
| Approval       | Approval               |
| ApprovalForAll | ApprovalForAll         |
| Adjust         | AdjustFlowStream       |
| Create         | CreateFlowStream       |
| Deposit        | DepositFlowStream      |
| Pause          | PauseFlowStream        |
| Refund         | RefundFromFlowStream   |
| Restart        | RestartFlowStream      |
| Transfer       | Transfer               |
| Void           | VoidFlowStream         |
| Withdraw       | WithdrawFromFlowStream |

To keep all actions under the same umbrella, some details will be stored under general purpose attributes like
`amountA`, `amountB`, `addressA`, `addressB` which based on the type of action can be resolved to context-specific
values. Am example can be found
[here](https://github.com/sablier-labs/indexers/blob/52f00f31a89c91dcf24480a5d7d8b25c84467f15/apps/flow/src/mappings/handle-stream.ts#L53-L56)
for the Adjust event.

---

## Stream

### Identifying

Inside the contracts, streams will be assigned a unique `tokenId` (or `streamId`). While this makes it easy to identify
items at the contract level, we need to consider the following for both subgraphs and client interfaces:

- items should be uniquely recognizable across multiple contract instances
- items should be uniquely identifiable across multiple chains
- items should be identifiable with short, easy to digest names

To address these observations, the subgraph uses two related identifiers for a Stream.

| Type           | Description                                                                                         | Example                        |
| -------------- | --------------------------------------------------------------------------------------------------- | ------------------------------ |
| `Stream.id`    | A self-explanatory structure built using the following structure: `contractAddress-chainId-tokenId` | <nobr>`0xAB..12-137-21`</nobr> |
| `Stream.alias` | A short version of the `id` where the contract is aliased: `contractAlias-chainId-tokenId`          | <nobr>`FL-137-21`</nobr>       |

Both examples from the table above translate to: **_a stream on Polygon (chain id `137`), within the Flow contract at
address `0xAB..12`, with the tokenId `21`_**.

:::note

The aliases defined in the subgraph will be used by client apps to resolve data about a stream. Make sure to keep them
in sync, avoid conflicts and regard them as immutable (once decided, never change them).

:::

### Aliases

To provide a simple visual structure, while also accounting for future stream curves (backwards compatibility) we use
the following abbreviations as aliases:

- FLOW V1.0 contracts become `FL`, e.g. `FL-137-1`

### Relevant parties

#### The recipient (gets paid\*)

As funds are being streamed, they will slowly become eligible to withdraw and spend unlocked tokens. The `recipient` is
defined at the start of the stream but can change as a result of a transfer.

On transfer, the old recipient moves the NFT (the stream itself) to another address, which becomes the new recipient.
Rights to withdraw and claim future streamed funds are naturally transferred to this new address.

#### The sender (will pay\*)

They are an immutable party, defined at the start of the stream. Based on the configuration chosen for the stream, they
will be entitled to later pause the stream, void it (stop and erased any accrued debt), withdraw on behalf of the
recipient or refund any of the unstreamed tokens.

## Asset

Tokens (ERC20) streamed through the protocol will be defined through an `Asset` entity.

:::info

As a development caveat, some ERC20 contracts are designed to store details (e.g. name, symbol) as `bytes32` and not
`string`. Prior to deploying a subgraph, make sure you take into account these details as part of any Asset entity
implementation. For examples, see the asset "helper" files inside this subgraph's repository code.

:::

---

## Batch and Batcher

The SablierFlow contracts through the implementation of the IBatch interface allow executing multiple actions in the
same transaction. One of these functionalities will be **batch stream creation** (or **stream grouping**). Using the
`batch` that receives the encoded data of multiple `create` function calls, a sender will be able to create multiple
streams at once - considered part of the same batch. This is similar with the
[lockup create multiple functions](/api/lockup/the-graph/structure#batch-and-batcher)

To identify these relationships between stream items, the `Batch` entity will group items created in the same
transaction, by finding events emitted with the same tx hash. The `Batcher` will then assign a user-specific unique
index to every group.

---

## Watcher

The Watcher (one for the entire subgraph) will provide specific utilities to the entire system, like global stream
identifiers (a numeric id unique to a stream across all contract instances) and global action identifiers.

================
File: docs/api/04-flow/03-envio/01-similarities.mdx
================
---
draft: true
id: "similarities"
sidebar_position: 1
title: "Similarities"
---

# Similarities

Envio indexers are designed to mirror the functionality and structure of the The Graph subgraphs.

For an introduction into the Sablier primitives and our architectural choices, check out the
[Flow subgraph](/api/flow/the-graph/entities) before reading about the `flow-envio` indexer.

Similar entities are used between The Graph and Envio setups.

- [Entities](/api/flow/the-graph/entities)
- [Structure](/api/flow/the-graph/structure)

================
File: docs/api/04-flow/03-envio/02-queries.mdx
================
---
draft: true
id: "queries"
sidebar_position: 2
title: "Queries"
---

Building on top of the [entity structure](/api/flow/the-graph/structure) defined earlier, here are some common GraphQL
queries for fetching data from the Sablier subgraph.

### Recent streams

```graphql title="The 10 most recent streams"
query getStreams {
  Stream(limit: 10, distinct_on: [subgraphId], order_by: { subgraphId: desc }) {
    id
    alias
    category
    asset {
      id
      symbol
    }
  }
}
```

### Paginated streams

To query streams in sets/pages (and avoid edge cases where using timestamps may skip simultaneous batched streams), we
can use the unique `subgraphId`.

This query includes pagination.

```graphql title="The next streams indexed before the last seen subgraphId"
query getStreams($first: Int!, $subgraphId: numeric!) {
  Stream(
    limit: $first
    distinct_on: [subgraphId]
    order_by: { subgraphId: desc }
    where: { subgraphId: { _lt: $subgraphId } }
  ) {
    id
    alias
    category
    asset {
      id
      symbol
    }
  }
}
```

### Streams by sender

This query includes pagination.

:::warning

Some queries, especially those using `OR` will potentially yield duplicate results. To make sure we only retrieve unique
streams/entities with a query, we make use of the `distinct_on` filter (and apply it on keys included in `order_by`).

:::

```graphql title="The next streams created by an address"
Stream(
  limit: $first
  offset: $skip
  distinct_on: [subgraphId]
  order_by: { subgraphId: desc }
  where: {
    _and: [{ sender: {_eq: $sender} }, { subgraphId: {_lt: $subgraphId} }]
  }
) {
  id
  alias
  category
}
```

### Streams by sender or recipient

To show all streams that have an address marked as a sender (all cases) or a recipient, extend the example above to
account for the recipient aspect.

This query includes pagination.

```graphql title="The next streams related to an address, as a sender or recipient"
Stream(
  limit: $first
  offset: $skip
  distinct_on: [subgraphId]
  order_by: { subgraphId: desc }
  where: {
    or: [
      { _and: [{ sender: {_eq: $sender} }, { subgraphId: {_lt:  $subgraphId} }] }
      { _and: [{ recipient: {_eq: $recipient} }, { subgraphId: {_lt: $subgraphId} }] }
    ]
  }
) {
    id
    alias
    category
  }
```

### Streams by filters

The official V2 Interfaces will provide a search interface where one may query for a list of streams using the following
filters (the conditions will be combined)

- the sender address
- the recipient address
- a list of stream identifiers

This query includes pagination.

```graphql title="The 'where' clause for a complex paginated search filter"
where: {
    _or: [
      {
        _and: [
          { chainId: { _eq: $chainId } }
          { sender: { _eq: $sender } }
          { subgraphId: { _lt: $subgraphId } }
        ]
      }
      {
        _and: [
          { chainId: { _eq: $chainId } }
          { recipient: { _eq: $recipient } }
          { subgraphId: { _lt: $subgraphId } }
        ]
      }
    ]
  }
```

### Actions by stream

:::tip

To avoid writing the same entity definitions over and over again, check out Fragments.

:::

```graphql title="Most recent 100 stream actions such as withdrawals or transfers"
Action(
  limit: 100
  distinct_on: [subgraphId]
  order_by: { subgraphId: desc }
  where: { stream_id: {_eq: $streamId} }
) {
  id
  category
  stream {
    ...StreamFragment
  }
}
```

================
File: docs/api/04-flow/01-indexers.mdx
================
---
id: "indexers"
sidebar_position: 1
title: "Indexers"
---

import TableEnvio from "@site/src/autogen/flow/TableEnvio.mdx";
import TableTheGraph from "@site/src/autogen/flow/TableTheGraph.mdx";
import LinkPreviewIndexers from "@site/src/components/molecules/link-previews/Indexers";
import ExplainerEnvio from "@site/src/snippets/ExplainerEnvio.mdx";
import ExplainerTheGraph from "@site/src/snippets/ExplainerTheGraph.mdx";

# Sablier Flow

This page documents the indexers for the [Sablier Flow](/concepts/flow/overview) protocol, which powers the [Payments](/apps/features/payments) product in the Sablier Interfaces.

## Envio

### Source Code

<LinkPreviewIndexers vendor="envio" protocol="flow" />

### Endpoints

<ExplainerEnvio />

<TableEnvio />

## The Graph

### Source Code

<LinkPreviewIndexers vendor="graph" protocol="flow" />

### Endpoints

<ExplainerTheGraph />

<TableTheGraph />

================
File: docs/api/04-flow/04-previous-indexers.mdx
================
---
id: "previous-indexers"
sidebar_position: 4
title: "Previous Indexers"
---

import DeprecatedIndexers from "@site/src/snippets/DeprecatedIndexers.mdx";

<DeprecatedIndexers />

| Chain            | Explorer                                                            | Studio[^2]                                | Decentralized Network[^1]                    |
| ---------------- | ------------------------------------------------------------------- | ----------------------------------------- | -------------------------------------------- |
| Ethereum         | [sablier-v2-fl][v2-flow-explorer-ethereum]                          | [Studio][v2-flow-studio-ethereum]         | [Network][v2-flow-network-ethereum]          |
| Arbitrum         | [sablier-v2-fl-arbitrum][v2-flow-explorer-arbitrum]                 | [Studio][v2-flow-studio-arbitrum]         | [Network][v2-flow-network-arbitrum]          |
| Arbitrum Sepolia | [sablier-v2-fl-arbitrum-sepolia][v2-flow-explorer-arbitrum-sepolia] | [Studio][v2-flow-studio-arbitrum-sepolia] | [Network][v2-flow-network-arbitrum-sepolia]  |
| Avalanche        | [sablier-v2-fl-avalanche][v2-flow-explorer-avalanche]               | [Studio][v2-flow-studio-avalanche]        | [Network][v2-flow-network-avalanche]         |
| Base             | [sablier-v2-fl-base][v2-flow-explorer-base]                         | [Studio][v2-flow-studio-base]             | [Network][v2-flow-network-base]              |
| Blast            | [sablier-v2-fl-blast][v2-flow-explorer-blast]                       | [Studio][v2-flow-studio-blast]            | [Network][v2-flow-network-blast]             |
| BNB Chain        | [sablier-v2-fl-bsc][v2-flow-explorer-bsc]                           | [Studio][v2-flow-studio-bsc]              | [Network][v2-flow-network-bsc]               |
| Chiliz Chain     | [sablier-v2-fl-chiliz][v2-flow-explorer-chiliz]                     | [Studio][v2-flow-studio-chiliz]           | [Network][v2-flow-network-chiliz]            |
| Gnosis           | [sablier-v2-fl-gnosis][v2-flow-explorer-gnosis]                     | [Studio][v2-flow-studio-gnosis]           | [Network][v2-flow-network-gnosis]            |
| Linea            | [sablier-v2-fl-linea][v2-flow-explorer-linea]                       | [Studio][v2-flow-studio-linea]            | [Network][v2-flow-network-linea]             |
| Lightlink        | [sablier-v2-fl-lightlink\*][v2-flow-explorer-lightlink]             | N/A                                       | [Lightlink Node\*][v2-flow-custom-lightlink] |
| Mode             | [sablier-v2-fl-mode][v2-flow-explorer-mode]                         | [Studio][v2-flow-studio-mode]             | [Network][v2-flow-network-mode]              |
| Optimism         | [sablier-v2-fl-optimism][v2-flow-explorer-optimism]                 | [Studio][v2-flow-studio-optimism]         | [Network][v2-flow-network-optimism]          |
| Optimism Sepolia | [sablier-v2-fl-optimism-sepolia][v2-flow-explorer-optimism-sepolia] | [Studio][v2-flow-studio-optimism-sepolia] | [Network][v2-flow-network-optimism-sepolia]  |
| Polygon          | [sablier-v2-fl-polygon][v2-flow-explorer-polygon]                   | [Studio][v2-flow-studio-polygon]          | [Network][v2-flow-network-polygon]           |
| Scroll           | [sablier-v2-fl-scroll][v2-flow-explorer-scroll]                     | [Studio][v2-flow-studio-scroll]           | [Network][v2-flow-network-scroll]            |
| Ethereum Sepolia | [sablier-v2-fl-sepolia][v2-flow-explorer-sepolia]                   | [Studio][v2-flow-studio-sepolia]          | [Network][v2-flow-network-sepolia]           |
| zkSync           | [sablier-v2-fl-zksync][v2-flow-explorer-zksync]                     | [Studio][v2-flow-studio-zksync]           | [Network][v2-flow-network-zksync]            |

{/* --------------------------------------------------------------------------------------------------------------------------------- */}
{/* --------------------------------------------------------------------------------------------------------------------------------- */}
{/* --------------------------------------------------------------------------------------------------------------------------------- */}

{/* Chain: Arbitrum */}

[v2-flow-network-arbitrum]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/61wTsPJr76vzcaMMrqQq7RkHSUsQmHoqiJbkFc1iaNN1
[v2-flow-explorer-arbitrum]: https://thegraph.com/explorer/subgraphs/61wTsPJr76vzcaMMrqQq7RkHSUsQmHoqiJbkFc1iaNN1
[v2-flow-studio-arbitrum]: https://api.studio.thegraph.com/query/57079/sablier-v2-fl-arbitrum/version/latest

{/* Chain: Arbitrum Sepolia */}

[v2-flow-network-arbitrum-sepolia]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/Ai8sJzb4W6B19kPzqWxe47R29YGw5dACy9AJ97nZzm5W
[v2-flow-explorer-arbitrum-sepolia]: https://thegraph.com/explorer/subgraphs/Ai8sJzb4W6B19kPzqWxe47R29YGw5dACy9AJ97nZzm5W
[v2-flow-studio-arbitrum-sepolia]: https://api.studio.thegraph.com/query/57079/sablier-v2-fl-arbitrum-sepolia/version/latest

{/* Chain: Avalanche */}

[v2-flow-network-avalanche]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/CUFanZFBBAaKcJDPLnCwWjo6gAruG92DcK38Y2PzARH8
[v2-flow-explorer-avalanche]: https://thegraph.com/explorer/subgraphs/CUFanZFBBAaKcJDPLnCwWjo6gAruG92DcK38Y2PzARH8
[v2-flow-studio-avalanche]: https://api.studio.thegraph.com/query/57079/sablier-v2-fl-avalanche/version/latest

{/* Chain: Base */}

[v2-flow-network-base]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/DVuHKeqguX339rd6JGav7wjXBVi5R4qneHSDNu1urTKr
[v2-flow-explorer-base]: https://thegraph.com/explorer/subgraphs/DVuHKeqguX339rd6JGav7wjXBVi5R4qneHSDNu1urTKr
[v2-flow-studio-base]: https://api.studio.thegraph.com/query/57079/sablier-v2-fl-base/version/latest

{/* Chain: Blast */}

[v2-flow-network-blast]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/84gjGqyeWDG2VxvRTRjTFxrnPMuZhAYF4iETBox2ix5D
[v2-flow-explorer-blast]: https://thegraph.com/explorer/subgraphs/84gjGqyeWDG2VxvRTRjTFxrnPMuZhAYF4iETBox2ix5D
[v2-flow-studio-blast]: https://api.studio.thegraph.com/query/57079/sablier-v2-fl-blast/version/latest

{/* Chain: BSC */}

[v2-flow-network-bsc]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/GJvqaYwX9vGXPXDFrANs6LcDALcN22bjvvPvrcNvU8rn
[v2-flow-explorer-bsc]: https://thegraph.com/explorer/subgraphs/GJvqaYwX9vGXPXDFrANs6LcDALcN22bjvvPvrcNvU8rn
[v2-flow-studio-bsc]: https://api.studio.thegraph.com/query/57079/sablier-v2-fl-bsc/version/latest

{/* Chain: Chiliz */}

[v2-flow-network-chiliz]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/H5LERpVjK2ugD42PX774kv5shHfqd13HkBPWtASq75L4
[v2-flow-explorer-chiliz]: https://thegraph.com/explorer/subgraphs/H5LERpVjK2ugD42PX774kv5shHfqd13HkBPWtASq75L4
[v2-flow-studio-chiliz]: https://api.studio.thegraph.com/query/57079/sablier-v2-fl-chiliz/version/latest

{/* Chain: Gnosis */}

[v2-flow-network-gnosis]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/3XxHfFUMixMJTGVn1FJFFER1NFYpDDQo4QAbR2sQSpAH
[v2-flow-explorer-gnosis]: https://thegraph.com/explorer/subgraphs/3XxHfFUMixMJTGVn1FJFFER1NFYpDDQo4QAbR2sQSpAH
[v2-flow-studio-gnosis]: https://api.studio.thegraph.com/query/57079/sablier-v2-fl-gnosis/version/latest

{/* Chain: Linea */}

[v2-flow-network-linea]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/25Ry5DsjAKLXh6b8uXSu6H85Jk9d3MHxQbpDUJTstwvx
[v2-flow-explorer-linea]: https://thegraph.com/explorer/subgraphs/25Ry5DsjAKLXh6b8uXSu6H85Jk9d3MHxQbpDUJTstwvx
[v2-flow-studio-linea]: https://api.studio.thegraph.com/query/57079/sablier-v2-fl-linea/version/latest

{/* Chain: Lightlink */}

[v2-flow-explorer-lightlink]: https://graph.phoenix.lightlink.io/query/subgraphs/name/lightlink/sablier-v2-fl-lightlink/graphql
[v2-flow-custom-lightlink]: https://graph.phoenix.lightlink.io/query/subgraphs/name/lightlink/sablier-v2-fl-lightlink

{/* Chain: Mainnet | Ethereum */}

[v2-flow-explorer-ethereum]: https://thegraph.com/explorer/subgraphs/DgXaXAUMFTZdwo1aZ21dmGV2vyU1Wdb1DkHyVmy3y7xi
[v2-flow-studio-ethereum]: https://api.studio.thegraph.com/query/57079/sablier-v2-fl/version/latest
[v2-flow-network-ethereum]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/DgXaXAUMFTZdwo1aZ21dmGV2vyU1Wdb1DkHyVmy3y7xi

{/* Chain: Mode */}

[v2-flow-network-mode]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/H9D24a58cCZmzZTnu4VNdUoFCEMhNYjHP9uohXr9Qi65
[v2-flow-explorer-mode]: https://thegraph.com/explorer/subgraphs/H9D24a58cCZmzZTnu4VNdUoFCEMhNYjHP9uohXr9Qi65
[v2-flow-studio-mode]: https://api.studio.thegraph.com/query/57079/sablier-v2-fl-mode/version/latest

{/* Chain: Optimism */}

[v2-flow-network-optimism]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/JAf9rM9bn6Z91htddJ33JAyrWdNXHmseHhvx11Bpfysg
[v2-flow-explorer-optimism]: https://thegraph.com/explorer/subgraphs/JAf9rM9bn6Z91htddJ33JAyrWdNXHmseHhvx11Bpfysg
[v2-flow-studio-optimism]: https://api.studio.thegraph.com/query/57079/sablier-v2-fl-optimism/version/latest

{/* Chain: Optimism Sepolia */}

[v2-flow-network-optimism-sepolia]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/5tosMw7VVdE9ie3Z8Hdz6Y4SqaMaKrBb3XnM9rTYUag2
[v2-flow-explorer-optimism-sepolia]: https://thegraph.com/explorer/subgraphs/5tosMw7VVdE9ie3Z8Hdz6Y4SqaMaKrBb3XnM9rTYUag2
[v2-flow-studio-optimism-sepolia]: https://api.studio.thegraph.com/query/57079/sablier-v2-fl-optimism-sepolia/version/latest

{/* Chain: Polygon */}

[v2-flow-network-polygon]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/G49hZr29bZK7TAa7KK8z4sZ3ZkL93Ss6CZDG6ffCSifV
[v2-flow-explorer-polygon]: https://thegraph.com/explorer/subgraphs/G49hZr29bZK7TAa7KK8z4sZ3ZkL93Ss6CZDG6ffCSifV
[v2-flow-studio-polygon]: https://api.studio.thegraph.com/query/57079/sablier-v2-fl-polygon/version/latest

{/* Chain: Scroll */}

[v2-flow-network-scroll]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/2d1uvMnHnohZowpGwDdj6Gpk5gT8SNcZjbLfTA3JVRa8
[v2-flow-explorer-scroll]: https://thegraph.com/explorer/subgraphs/2d1uvMnHnohZowpGwDdj6Gpk5gT8SNcZjbLfTA3JVRa8
[v2-flow-studio-scroll]: https://api.studio.thegraph.com/query/57079/sablier-v2-fl-scroll/version/latest

{/* Chain: Ethereum Sepolia */}

[v2-flow-network-sepolia]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/iYRc4ETBqkeiyVhMeXktJ9jxEuQhQ1eJb2Bv68mGkQm
[v2-flow-explorer-sepolia]: https://thegraph.com/explorer/subgraphs/iYRc4ETBqkeiyVhMeXktJ9jxEuQhQ1eJb2Bv68mGkQm
[v2-flow-studio-sepolia]: https://api.studio.thegraph.com/query/57079/sablier-v2-fl-sepolia/version/latest

{/* Chain: zkSync */}

[v2-flow-network-zksync]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/iYRc4ETBqkeiyVhMeXktJ9jxEuQhQ1eJb2Bv68mGkQm
[v2-flow-explorer-zksync]: https://thegraph.com/explorer/subgraphs/iYRc4ETBqkeiyVhMeXktJ9jxEuQhQ1eJb2Bv68mGkQm
[v2-flow-studio-zksync]: https://api.studio.thegraph.com/query/57079/sablier-v2-fl-zksync/version/latest

{/* --------------------------------------------------------------------------------------------------------------------------------- */}

[endpoint-flow]: https://indexer.hyperindex.xyz/3b4ea6b/v1/graphql

{/* --------------------------------------------------------------------------------------------------------------------------------- */}
{/* --------------------------------------------------------------------------------------------------------------------------------- */}
{/* --------------------------------------------------------------------------------------------------------------------------------- */}

================
File: docs/api/06-caveats.mdx
================
---
id: "caveats"
sidebar_position: 6
title: "Caveats"
---

# Caveats

## Query Syntax

Both The Graph and Envio provide a **GraphQL** API for consumers to read data from. The Graph uses a customized subset of GraphQL
operations, whereas Envio deploys a GraphQL API over a Postgres DB. Unfortunately, this makes is impossible to use the exact same queries between the two services.

Here are some examples:

| Example              | The Graph                             | Envio                                      |
| -------------------- | ------------------------------------- | ------------------------------------------ |
| Pagination           | `first`, `skip`                       | `limit`, `offset`                          |
| Filter by id         | `stream(id)`                          | `Stream(where: {id: {_eq: 1}})`            |
| Single vs. Plural    | `stream(id){}`, `streams{}`           | `Stream(where...){}` for both              |
| Nested items         | `campaigns{ id, asset: {id, symbol}}` | `Campaign{ asset_id, asset: {id, symbol}}` |
| Filter similar items | `assets(id: $id)`                     | `Asset(where: {id: {_iregex: $id}})`       |

Notes:

- For the 3rd example, querying for a single item vs. a collection will have separate keywords for The Graph. With
  Envio, you'll have to identify within the app itself if the query is supposed to yield one or multiple items. As you
  may tell, with Envio you'll query for `Stream` (capitalized), while with The Graph you'll query for `stream` or
  `streams`.
- For the 4th example, Envio Indexers will yield the contents of the `name` of an object with (`{}`), while the
  `<name>_id` label will ask for the identifier of the object (e.g., `asset` vs `asset_id`). Keep this in mind for
  "where" filtering.

================
File: docs/apps/guides/03-how-to.mdx
================
---
id: "how-to"
sidebar_position: 2
title: "How-to Videos"
---

For an extensive set of video explanations please check out the [Support](/support/how-to) section.

================
File: docs/apps/04-legacy-v1.mdx
================
---
id: "v1"
sidebar_position: 4
title: "Legacy"
---

## Sablier Legacy

The first version of the Sablier protocol will keep running in perpetuity thanks to the Ethereum blockchain, but the
current Sablier Interfaces are not compatible with the Legacy protocol. We will keep hosting the legacy apps so that you
can manage any streams previously created on V1.

- Sender interface: [v1-pay.sablier.com](https://v1-pay.sablier.com)
- Recipient interface: [v1-app.sablier.com](https://v1-app.sablier.com)

================
File: docs/support/02-technical-guides.mdx
================
---
id: "technical-guides"
sidebar_position: 2
title: "Technical Guides"
---

## Guides for Apps

Hands-on guides for app-specific features:

- [CSV Support](/apps/guides/csv-support) (for streams and airdrops)
- [URL Schemes](/apps/guides/url-schemes)

## Guides for Contracts

- [Interactions with Etherscan](/guides/lockup/etherscan)
- [Lockup Stream Management](/guides/lockup/examples/stream-management/withdraw)
- And more...

## Guides for Subgraphs

See the dedicated APIs [page](/api/overview).

- [Popular subgraph queries](/api/lockup/the-graph/queries)
- [Merkle tree management](/api/airdrops/merkle-api/examples) for airdrops

================
File: docs/apps/features/02-vesting.mdx
================
---
id: "vesting"
sidebar_position: 2
title: "Vesting"
---

# Vesting

import LockupNFTSVG from "@site/static/img/nft/lockup.svg";

The Sablier Interface will showcase [Lockup](/concepts/lockup/overview) streams under the Vesting tab. These are token
streams with a fixed duration, predefined amount and strict distribution curve.

![Banner Vesting](/img/banners/docs-vesting.webp)

In Q4 2024 the app has undergone a use-case centric redesign. For past users, all streams created before this update
will show up in the Vesting page.

| [Vesting streams](https://app.sablier.com/vesting/gallery)                               |
| ---------------------------------------------------------------------------------------- |
| <img alt="Vesting stream profile" width="100%" src="/screenshots/vesting-gallery.webp"/> |

## Features

### Flexible curves

Almost any vesting schedule can be expressed as a stream. Sablier supports multiple options out of the box, including:

- Linear
- Cliff-Linear
- Unlock in Steps
- Unlock Monthly
- Backweighted
- Timelock
- Unlock-Linear
- Unlock-Dynamic
- Exponential
- Cliff-Exponential

But programmatically, you can create any schedule you want. See the [Stream Shapes](/concepts/lockup/stream-shapes) for
more details on how we design these shapes.

### Explore the dashboard

Enter the Dashboard and discover a detailed overview of your incoming and outgoing streams.

Take advantage of the Search functionality to explore the chain and gain more insight into how others are using Lockup
for vesting.

|                                             |
| ------------------------------------------- |
| ![All](/screenshots/vesting-dashboard.webp) |

### Preview any stream

Gain insight into any stream. Track progress using our very own stream circle. Share the unique URL with recipients or
anyone really to increase transparency of your day to day token distribution.

|                                           |
| ----------------------------------------- |
| ![All](/screenshots/vesting-profile.webp) |

### NFT representation

Each stream in wrapped in an ERC-721 non-fungible token (NFT), making the stream recipient the owner of the NFT.

Thus streams can be transferred, traded, and used as collateral in NFT lending protocols.

|                                           |
| ----------------------------------------- |
| <LockupNFTSVG height={500} width={500} /> |

### Multi-chain experience

Streaming, everywhere. We support 11+ EVM chains and testnets where you can stream or get paid using Sablier.

|                                                |
| ---------------------------------------------- |
| ![ChainList](/screenshots/general-chains.webp) |

### Create in bulk

Save time by creating up to 280 streams in bulk for your employees, investors, or community members. Use the forms for a
clean and straightforward UX.

|                                                     |
| --------------------------------------------------- |
| ![Create in bulk](/screenshots/vesting-create.webp) |

### Create with CSV

As an alternative to manually filling out the form, you can upload a CSV file with your user data.

|                                                          |
| -------------------------------------------------------- |
| ![Create with CSV](/screenshots/vesting-create-csv.webp) |

### Simulations

Eager to see what your token distribution will look like? Use our simulation tool right from the stream creation forms
(or later, from the stream profile).

![Simulate](/screenshots/simulation.webp)

### Detailed panels

Explore each available stream in detail. Simulate future payouts, understand historical events, or simply enjoy cool
representations of a monetized passage of time (NFTs ).

### Granular management

Manage your streams 24/7 as you see fit. The app will guide you through every supported process and help you keep an eye
on your payouts. Remember, you can always be both a sender and a recipient.

|                                               |                                           |
| --------------------------------------------- | ----------------------------------------- |
| ![Withdraw](/screenshots/cover-withdraw.webp) | ![Cancel](/screenshots/cover-cancel.webp) |

### Any ERC-20 token

Thanks to our integration of Token Lists, any ERC-20 token can be distributed via Sablier Lockup.

:::warning

The only exception is rebasing tokens like Aave's aTokens. Tokens that dynamically rebase their balance are not
supported by Sablier.

:::

|                                                 |                                                          |
| ----------------------------------------------- | -------------------------------------------------------- |
| ![Token List](/screenshots/tokenlist-home.webp) | ![Token List Search](/screenshots/tokenlist-search.webp) |

### Mobile-ready layout

Token streams on the go!

Yes, the Sablier app works on mobile. And yes, we support dark mode by default (light mode coming soon).

### Permissions

We've mapped the most important utilities from the Lockup contracts into in-app features. Interact with streams that
reference you as a key participant (e.g. sender, recipient) directly from the interfaces.

| Feature                | Sender | Recipient | Public |
| ---------------------- | :----: | :-------: | :----: |
| Create Streams         |      |     -     |   -    |
| Renounce Cancelability |      |         |   -    |
| Cancel                 |      |         |   -    |
| Transfer               |      |         |   -    |
| Withdraw               |      |         |      |

### Safe multisig support

Vesting is fully integrated with [Safe](https://safe.global). Start streaming from the safety and comfort of your
multisig wallet.

================
File: docs/concepts/lockup/02-stream-shapes.mdx
================
---
id: "stream-shapes"
sidebar_position: 2
title: "Stream Shapes"
---

import FunctionPlot from "@site/src/components/organisms/FunctionPlot";

:::note

- The code used to generate the gas benchmarks for the different stream curves can be found
  [here](https://github.com/sablier-labs/examples/tree/shapes-benchmark).

- If you are interested in learning how to programmatically create the curves shown below in Solidity, check out the
  [examples](https://github.com/sablier-labs/examples/blob/main/lockup/) repository and the "CurvesCreator" files.

:::

## Lockup Linear

### Linear

Lockup Linear streams are the simplest token distribution curve in Sablier. The streamed amount over time follows a
straight line that goes up and to the right on a graph, which corresponds to the identity function $f(x) = x$:

<FunctionPlot options={{ data: [{ fn: "x", color: "#f77423" }] }} />

With this shape of stream, the payment rate remains constant, meaning that the same fraction of the deposit amount is
streamed to the recipient every second. This provides greater predictability and is easy to understand because of how
intuitive it is. Imagine a diagonal line going up and to the right  that's how simple it is.

:::info

The gas cost to create this shape is approximately _168,923_ on Mainnet. This may vary due to multiple factors.

:::

### Initial Unlock

The Unlock Linear shape combines an initial immediate release of tokens with a steady, linear payout over time. This
shape is ideal for employment contracts that include a signing bonus along with a regular payout schedule.

<FunctionPlot
  options={{
    data: [
      { fn: "25", range: [0, 0.15], color: "#f77423" },
      { fn: "(x-0.15)*0.75015 + 25", range: [0.15, 100], color: "#f77423" },
      {
        points: [
          [0.15, 0],
          [0.15, 25],
        ],
        fnType: "points",
        graphType: "polyline",
        color: "#f77423",
      },
    ],
  }}
/>

At the beginning of the stream, a fixed amount of tokens is instantly available to the recipient  this is your "signing
bonus". Following this, the remaining tokens begin to stream continuously at a consistent rate until the end of the
contract term  this is your "salary".

Another use case is a token distribution to investors where a particular amount gets unlocked immediately followed by a
linear vesting plan.

:::info

The gas cost to create this shape is approximately _191,182_ on Mainnet. This may vary due to multiple factors.

:::

### Cliff Unlock

It is possible to attach a "cliff" to a Lockup Linear stream, which sets a cut-off point for releasing tokens. Prior to
the cliff, the recipient cannot withdraw any tokens, but the stream continues to accrue them. After the cliff, the
constant payment rate per second kicks in.

<FunctionPlot
  options={{
    data: [
      { fn: "0", range: [0, 25], color: "#f77423" },
      { fn: "x", range: [25, 100], color: "#f77423" },
      {
        points: [
          [25, 0],
          [25, 25],
        ],
        fnType: "points",
        graphType: "polyline",
        color: "#f77423",
      },
    ],
  }}
/>

This feature is especially useful for vesting ERC-20 tokens as it allows you to have, for example, a 1-year cliff, and
then 3 additional years of linear streaming. If the stream is for an employee, you can make it cancellable so that if
the employee leaves your company during the stream, you can cancel it and recover the tokens that have not yet been
streamed.

:::info

The gas cost to create this shape is approximately _213,708_ on Mainnet. This may vary due to multiple factors.

:::

### Initial Cliff Unlock

This shape is useful for companies who want to distribute tokens to their investors using a cliff followed by linear
vesting but also want to unlock some liquidity at the beginning to be able to allow investors to bootstrap AMM pools.

<FunctionPlot
  options={{
    data: [
      { fn: "0", range: [0, 50], color: "#f77423" },
      { fn: "x", color: "#f77423", range: [50, 100] },
      {
        points: [
          [0.15, 0],
          [0.15, 25],
          [50, 25],
          [50, 50],
        ],
        fnType: "points",
        graphType: "polyline",
        color: "#f77423",
      },
    ],
  }}
/>

Initially, a set amount of tokens are made available to the recipient as an upfront payment. After this initial unlock,
the tokens are held during the cliff period until the moment of time set. The release resumes in a linearly post-cliff.

:::info

The gas cost to create this shape is approximately _214,067_ on Mainnet. This may vary due to multiple factors.

:::

## Lockup Dynamic

Lockup Dynamic streams are what makes Sablier so unique, since they enable the creation of an arbitrary streaming curve,
including non-linear curves.

On the Sablier Interface, we support only some distribution shapes (the ones enumerated below), but the potential for
innovation is limitless when you interact programmatically with the contracts. For example, one could design a
logarithmic stream that emulates the $f(x) = log(x)$ function.

These streams are powered by a number of user-provided [segments](/concepts/lockup/segments), which we will cover in the
next article. What is important to note here is that with Lockup Dynamic, Sablier has evolved into a universal streaming
engine, capable of supporting any custom streaming curve.

### Exponential

A fantastic use case for Lockup Dynamic is Exponential streams, a shape through which the recipient receives
increasingly more tokens as time passes.

<FunctionPlot options={{ data: [{ fn: "(x/70)^6 * 12", color: "#f77423" }] }} />

Exponentials are a great fit if you are looking to airdrop tokens, because your community members will receive the
majority of the tokens towards the end of the stream instead of receiving the tokens all at once (no streaming) or in a
linear fashion (Lockup Linear). This incentivizes long-term behavior and a constructive attitude.

:::info

The gas cost to create this shape is approximately _219,629_ on Mainnet. This may vary due to multiple factors.

:::

### Cliff Exponential

Another use case for Lockup Dynamic is a variation of the previous design: an Cliff Exponential.

<FunctionPlot
  options={{
    data: [
      { fn: "0", range: [0, 50], color: "#f77423" },
      { fn: "(x/70)^6 * 9.6 + 18.672", color: "#f77423", range: [50, 100] },
      {
        points: [
          [50, 0],
          [50, 20],
        ],
        fnType: "points",
        graphType: "polyline",
        color: "#f77423",
      },
    ],
  }}
/>

The stream starts with a cliff (which can be how long you want), a specific amount instantly unlocked when the cliff
ends, and then the rest of the stream is exponentially streamed.

This is an excellent distribution if you are a company looking to set up a token vesting plan for your employees. Your
employees will have an incentive to remain with your company in the long run, as they will receive an increasingly
larger number of tokens.

:::info

The gas cost to create this shape is approximately _274,420_ on Mainnet. This may vary due to multiple factors.

:::

## Lockup Tranched

Lockup Tranched streams are, as the name says, streams that have token unlocks in tranches. Even though you can use
Lockup Dynamic to create a traditional vesting structure with periodic unlocks, Lockup Tranched is specifically design
for that use case. As a result, a stream with tranches created using Lockup Tranched is more gas efficient than the same
stream created using Lockup Dynamic.

These streams are powered by a number of user-provided [tranches](/concepts/lockup/tranches), which is covered in the
tranches article.

### Unlock in Steps

You can use Lockup Tranched to create a traditional vesting contract with periodic unlocks. In this case, the
"streaming" rate would not be by the second, but by the week, month, or year.

<FunctionPlot
  options={{
    data: [
      {
        points: [
          [0.01, 0.01],
          [25, 0],
          [25, 25],
          [50, 25],
          [50, 50],
          [75, 50],
          [75, 75],
          [99.99, 75],
          [99.99, 99.99],
        ],
        fnType: "points",
        graphType: "polyline",
        color: "#f77423",
      },
    ],
  }}
/>

After each period, a specific amount becomes unlocked and available for the recipient to withdraw. Past unlocks
accumulate, so if the recipient doesn't withdraw them, they will be able to withdraw them later.

The advantage of using Unlock in Steps instead of a normal vesting contract is that Sablier automates the entire
process. No more worries about setting up vesting contracts or creating a user interface for your investors to claim
their tokens.

:::info

The gas cost to create this shape is approximately _299,268_ on Mainnet for four unlocks. This may vary as there are
multiple factors to consider.

:::

### Unlock Monthly

Unlock Monthly is a special case of Unlock in Steps where tokens are unlocked on the same day every month, e.g. the 1st
of every month. This is suited for use cases like traditional monthly salaries or ESOPs plans.

<FunctionPlot
  options={{
    xAxisLabel: "x - Months",
    xDomainLimit: 12,
    yDomainLimit: 120,
    data: [
      {
        fnType: "points",
        graphType: "polyline",
        color: "#f77423",
        points: Array.from({ length: 24 }, (_, i) => [
          1 + Math.floor(i / 2),
          10 * Math.floor(i / 2) + (i % 2 === 1 ? 10 : 0),
        ]),
      },
    ],
  }}
/>

Each month, on a particular day, a specific amount of tokens becomes unlocked and available for withdrawal. Like Unlock
in Steps, unwithdrawn tokens will carry over to the next period, providing flexibility and control to the recipient.
This shape is ideal for employers who wish to set up advanced payment schedules for their employees, offering them
access to funds on a predictable, monthly basis.

:::info

The gas cost to create this shape is approximately _511,476_ on Mainnet for a period of exactly **one year**. This may
vary as there are multiple factors to consider.

:::

### Timelock

The Timelock shape locks all tokens for a specified period. Users cannot access the tokens until the set period elapses.

<FunctionPlot
  options={{
    data: [
      {
        points: [
          [0.01, 0.01],
          [90, 0],
          [90, 99.7],
          [99.99, 99.99],
        ],
        fnType: "points",
        graphType: "polyline",
        color: "#f77423",
      },
    ],
  }}
/>

Once the set period elapses, the full amount becomes accessible to the recipient. This setup is particularly
advantageous for projects seeking to stabilize token pricing and minimize market volatility, encouraging investors to
maintain their stake over a more extended period.

:::info

The gas cost to create this shape is approximately _219,700_ on Mainnet. This may vary due to multiple factors.

:::

================
File: docs/concepts/03-use-cases.mdx
================
---
id: "use-cases"
sidebar_position: 3
title: "Use Cases"
---

import Link from "@docusaurus/Link";
import { Links } from "@site/src/constants";

While Lockup and Flow both are general-purpose protocols that can be used for a wide variety of applications, some use
cases are more popular than others. In this article, we will cover the primary reasons people are using Sablier Lockup
and Sablier Flow.

## Sablier Lockup

Sablier Lockup requires fixed dates and fixed amounts. When creating a stream, the total amount of tokens to be
distributed needs to be deposited into the stream and you cannot add funds to an existing stream. Lockup streams have a
fixed start date and end date, and cannot be extended. These properties make for an excellent user experience for
vesting, as the terms are clear, defined and transparent.

### Vesting

#### 1. Efficiency

Traditional vesting schemes require a lot of manual input. Payments must be processed manually over an extended period,
demanding continuous dedication from the treasury management team. The treasury admin has to initiate numerous
transactions each month to compensate contributors and oversee the vesting of employees and investors

As a result, traditional vesting proves to be labor-intensive, prone to errors, and ultimately delivers a subpar user
experience for everyone involved. Organizations need to devote considerable time to administer funds, while recipients
wait months, quarters, or sometimes even longer to obtain their compensation.

Sablier solves these problems by automating the entire vesting process.

The initial setup involves creating the streams, which only needs to be done once. You simply specify the total duration
of the stream (e.g., two years), and that's all - no further actions are required from you. With Sablier, vesting is a
"set it and forget it" process.

Then, recipients receive their compensation gradually over time: with every second that passes, they receive a fraction
of their allocated compensation. This model aligns with the incentives of both parties. The organization only needs to
spend time once, to create the streams, while recipients receive the funds gradually over time, allowing them to manage
their finances as they wish.

#### 2. Schelling points

:::info

In game theory, a "focal point" (also called Schelling point) is a solution that people tend to choose by default in the
absence of communication.

:::

Since traditional vesting contracts have a predictable release schedule, the day on which a vesting period unlocks may
be used as a Schelling point for speculation. As a result, some token holders may dump their tokens as soon as they
receive them.

By contrast, Sablier streams distribute a fraction of the total payment every second to recipients, enabling them to
withdraw a portion of funds at any time. This effectively addresses the problem of coordinated dumping.

#### 3. Transparency

It's hard to aggregate discrete payments, which is why they typically lack transparency. Just by looking at a
transaction on Etherscan, it's difficult to pin down to whom it was made, or for what purpose. This issue is
particularly relevant to DAOs, where transparency is critical to enabling contributors to understand how the treasury
funds are allocated and for what purposes.

With Sablier streams, the issues mentioned above are avoided. Anyone can use the Sablier interface to monitor all
streams created by a particular address, as well as all transactions associated with each stream.

To illustrate this, <Link href={Links.example}>here</Link>'s an example of a stream as viewed on the Sablier Interface.

## Merkle Airdrops

This section explores the use cases enabled by Merkle Airdrops.

### Instant airdrops

Instant airdrops is the traditional way of running airdrops where there's no vesting period and tokens can instantly be
claimed by the recipients. Running an airdrop campaign can become very expensive if you are storing airdrop data
on-chain, however.

This is where Merkle Airdrops come into the picture. When you run a campaign with Sablier, the airdrop information is
stored in a merkle tree, hosted on IPFS. The EVM storage only stores the root of the Merkle tree. At the time of claim,
eligible users can provide a merkle proof of their claim which is verified on-chain.

This not only reduces cost of running an airdrop campaigns but also inherits the security of the Sablier protocol.

### Streaming airdrops

With vested airdrops, also called Airstreams, instead of airdropping the entirety of the token allocation all at once,
airdrop recipients receive a fraction of the tokens every second through a Sablier stream.

A stream can have any duration you want. You can choose to vest your new token over a period of 6 months, 2 years, or
any other duration you prefer. This way, airdrop recipients are forced to think about the project's long-term
development and stay engaged with it.

1. The token price may fluctuate over time, which motivates recipients to do whatever they can to increase the price.
2. In cases where a recipient fails to remain involved with the project, the creator of the airdrop has the ability to
   cancel the recipient's stream. Canceling a stream will not undo any tokens that have already been streamed, but it
   will prevent the recipient from receiving any more tokens.

:::tip

If you are interested in airdropping your token, check out [Sablier website](https://app.sablier.com/airdrops/).

:::

## Sablier Flow

Unlike Lockup, Sablier Flow streams do not require upfront deposits, nor do they have fixed start and end dates. Flow is
all about flexibility, making it ideal for use cases like payroll and grants.

### Payroll

What if your salary could be streamed to you in real time? Why should you wait for two weeks or a month when you can get
it every second? Streaming salaries through Sablier significantly enhances employee satisfaction and retention.

Your employer can create a Flow stream and keep funding it at the end of every month or in advance, for you to withdraw
your money.

The benefits outlined in the "Efficiency" section earlier apply equally to this use case, since traditional payroll
solutions, like vesting schemes, can be both labor-intensive and prone to errors.

### Grants

Grants are a powerful use case for Sablier, allowing for efficient, transparent, and flexible distribution of funds to
grant recipients.

:::info

Uniswap Governance used Sablier to distribute grant to DeFi Education Fund. You can find more details on it
[here](https://x.com/Sablier/status/1798010170133692730).

:::

#### 1. Transparency

Sablier enables real-time streaming of funds, ensuring transparency in how grants are distributed. Your stakeholders can
monitor the flow of funds, providing assurance that the money is being used as intended.

#### 2. Pay as they deliver

Instead of lump-sum payments, you can use Sablier to stream funds continuously over a specified period. This ensures
recipients have a steady cash flow and reduces the risk of mismanagement of funds. If a grant recipient stops working on
their project, you can cancel the stream and retrieve back the remaining funds.

#### 3. No Administrative Overhead

All streams through Sablier are automated, which means, you don't have to send funds manually at the end of every month.

================
File: docs/concepts/05-merkle-airdrops.mdx
================
---
id: "merkle-airdrops"
sidebar_position: 5
title: "Merkle Airdrops"
---

import Link from "@docusaurus/Link";
import { Links } from "@site/src/constants";

:::note

You can refer to the [airdrop section](/concepts/use-cases#merkle-airdrops) of our use-cases page to learn more about
the benefits of streaming airdrops.

:::

There are three types of airdrop campaigns that you can setup using Sablier Merkle Airdrops.

## Instant Airdrop

Instant airdrops is the traditional way of running airdrops where there's no vesting period and tokens can instantly be
claimed by the recipients.

Eligible users receive airdrop tokens directly into their wallets at the claim time.

## Airstreams

Airstreams are vested airdrops in which instead of airdropping the entirety of the token allocation all at once, airdrop
recipients receive a fraction of the tokens every second through a Sablier stream.

The gist of Airstreams is that instead of airdropping the entirety of the tokens all at once, airdrop recipients receive
a fraction of the tokens every second through a token stream.

The beauty of it is that airdrop recipients are forced to think long-term and keep the project's future as their first
and foremost priority. They are forced to, because instead of receiving all the tokens at once, they receive them over
time in our user-friendly [Airstreams interface](https://app.sablier.com/airdrops).

:::info

An airdrop campaign can have a claim window of a few days, months, or even years. Alternatively, they can have no
expiration. In case of Airstreams, you could, for example, configure the airdrop of your new token to vest over years,
but the recipients get the streamed tokens only if a claim is made within that period of time.

:::

Airstreams not only create the right incentives for token holders, but also prevent them from dumping their tokens on
day one, as has been the case for many airdrops in the past.

There are two types of Airstream campaigns that you can create using Merkle Airdrop.

### Ranged Airstreams

This either uses Lockup Linear model or Lockup Tranched model depending on whether you use `MerkleLL` or `MerkleLT` to
create the campaign. In Ranged Airstream campaigns, the vesting begins for all the recipients at the same time. This
time had to be provided while creating the campaign.

### Non-Ranged Airstreams

In Non-Ranged Airstream campaigns, the vesting begins at the time of claiming. In this case, all recipients can have
different start time for Vesting depending on when they claim.

## White Label Solution

Sablier Labs does not currently offer any white label solutions for Merkle Airdrops. This means that you cannot have
your logo displayed in the claim page seen by the airstream recipients.

However, we are actively exploring implementing this feature. Fill out <Link href={Links.Forms.call}>this form</Link>
and we will respond as soon as possible.

## How it Works

Thanks to our battle-tested token distribution protocol, you can create Airdrop campaigns for thousands of recipients in
a few clicks using our interface. Recipients and their airdropped allocations can be set by uploading a simple CSV
spreadsheet in the [user interface](https://app.sablier.com/airdrops).

The spreadsheet feature is the perfect fit for merkle airdrop campaigns: it allows you to upload a CSV file with tens of
thousands of recipients and the interface will let each of these recipients claim with ease. You can download a tempalte
of the CSV file [here](https://files.sablier.com/templates/airstream-template.csv).

Another great advantage is that creating an airdrop campaign with thousands of recipients won't ruin you in terms of gas
fees. When launching a campaign, a contract is deployed only storing the merkle root. Thus, users pay the gas fee to
claim their airdrop. This is made possible by a data structure called Merkle Tree, which efficiently summarizes and
verifies the integrity of large sets of data.

:::info

The contracts that implements Airstream Campaigns are called
[`MerkleLL`](/reference/airdrops/contracts/contract.SablierMerkleLL) and
[`MerkleLT`](/reference/airdrops/contracts/contract.SablierMerkleLT). If you are interested into Instant Airdrop
Campaign, the contract code can be found [here](/reference/airdrops/contracts/contract.SablierMerkleInstant).

:::

When you create an Airdrop campaign, all you are doing is deploying a contract that allows for the recipients you put in
to prove that they are eligible, and create a stream if they are. That's all it is.

Additionally, you don't have to immediately fund the Campaign contract. You can just create the contract and at a later
date fund it with the airdropped tokens.

**This has three great implications:**

1. **Recipients pay for the gas fees themselves to create the stream**, when they claim (the claim action creates the
   stream). Creating a campaign with thousands of recipients would be incredibly costly if you had to pay for all the
   gas fees.
2. **You keep full control over unclaimed Tokens**. If a recipient doesn't claim their airdrop, it's not created, and
   you remain in full control over their allocation.

   - This applies only if the campaign has an expiration date. If there is no expiration date, you can only clawback
     during the grace period, and the recipients can claim their airdrop at any time in the future.

3. **You can retrieve your funds in case of misconfiguration**. There is a grace period during which you can retrieve
   unclaimed funds. The grace period ends 7 days after the first claim is made. This is useful in case where you have
   incorrectly configured the campaign or deposited more tokens than required.

Once the campaign is launched, recipients can claim their airdrop and withdraw the underlying tokens that have already
been streamed at any time using the Sablier Interface at [app.sablier.com](https://app.sablier.com).

## Diagram

If you want to have a detailed look into how these campaigns work at the contract level, you can head over to the
[Diagrams page](/reference/airdrops/diagrams).

================
File: docs/guides/airdrops/examples/01-local-environment.mdx
================
---
id: "local-environment"
sidebar_position: 1
title: "Configure Your Local Environment"
---

import {
  Introduction,
  Prerequisite,
  SetupWithFoundry,
  InstallNpm,
  FinalSteps,
} from "@site/src/snippets/LocalEnvironment.mdx";

<Introduction protocol="Airdrops" />

## Pre-requisites

<Prerequisite />

## Set up using Foundry template

:::tip

Make sure you are using the latest version of Foundry by running `foundryup`.

:::

<SetupWithFoundry protocol="Airdrops" />

:::note

You might notice that the CLI is `forge` rather than `foundry`. This is because Foundry is a toolkit, and `forge` is
just one of the tools that comes with it.

:::

## Install Merkle Airdrops npm packages

:::tip

If you are integrating with `MerkleLL` or `MerkleLT`, you will also have to install
[Lockup npm package](/guides/lockup/examples/local-environment#install-lockup-npm-packages). Both `MerkleLL` and
`MerkleLT` contracts interact with Lockup protocol to setup up vesting for airdropped tokens.

:::

<InstallNpm protocol="Airdrops" />

## Next steps

<FinalSteps protocol="Airdrops" />

================
File: docs/guides/airdrops/examples/02-create-campaign.mdx
================
---
id: "create-campaign"
sidebar_position: 2
title: "Create Campaigns"
---

import HardcodedDemonstration from "@site/src/components/atoms/HardcodedDemonstration";
import AdmonitionSimpleCode from "@site/src/snippets/AdmonitionSimpleCode.mdx";

# Create Airdrop Campaigns

In this guide, we will show you how you can use Solidity to create a campaign via the
[Merkle Factory](/reference/airdrops/contracts/contract.SablierMerkleFactory).

This guide assumes that you have already gone through the [Protocol Concepts](/concepts/merkle-airdrops) section.

<AdmonitionSimpleCode />

## Set up a contract

Declare the Solidity version used to compile the contract:

```solidity
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity >=0.8.22;
```

Now, import the relevant symbols from `@sablier/lockup` and `@sablier/airdrops`:

```solidity
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ud2x18 } from "@prb/math/src/UD2x18.sol";
import { ISablierLockup } from "@sablier/lockup/src/interfaces/ISablierLockup.sol";
import { ISablierMerkleInstant } from "@sablier/airdrops/src/interfaces/ISablierMerkleInstant.sol";
import { ISablierMerkleLL } from "@sablier/airdrops/src/interfaces/ISablierMerkleLL.sol";
import { ISablierMerkleLT } from "@sablier/airdrops/src/interfaces/ISablierMerkleLT.sol";
import { ISablierMerkleFactory } from "@sablier/airdrops/src/interfaces/ISablierMerkleFactory.sol";
import { MerkleBase, MerkleLL, MerkleLT } from "@sablier/airdrops/src/types/DataTypes.sol";
```

Create a contract called `MerkleCreator`, and declare a constant `DAI` of type `IERC20`, a constant `LOCKUP` of type
`ISablierLockup` and a constant `FACTORY` of type `ISablierMerkleFactory`.

```solidity
contract MerkleCreator {
    IERC20 public constant DAI = IERC20(0x68194a729C2450ad26072b3D33ADaCbcef39D574);
    ISablierMerkleFactory public constant FACTORY = ISablierMerkleFactory(0x4ECd5A688b0365e61c1a764E8BF96A7C5dF5d35F);
    ISablierLockup public constant LOCKUP = ISablierLockup(0xC2Da366fD67423b500cDF4712BdB41d0995b0794);
}
```

<HardcodedDemonstration protocol="Lockup" />

Factory address can be obtained from the [Merkle Airdrops Deployments](/guides/airdrops/deployments) page.

## Create function

There are three create functions available through factory:

- [`createMerkleInstant`](/reference/airdrops/contracts/contract.SablierMerkleFactory#createmerkleinstant): creates
  campaign for instant distribution of tokens.
- [`createMerkleLL`](/reference/airdrops/contracts/contract.SablierMerkleFactory#createmerklell): creates campaign with
  a Lockup Linear distribution.
- [`createMerkleLT`](/reference/airdrops/contracts/contract.SablierMerkleFactory#createmerklelt): creates campaign with
  a Lockup Tranched distribution.

Which one you choose depends upon your use case. In this guide, we will use `createMerkleLL`.

## Function definition

Define a function called `createMerkleLL` that returns the address of newly deployed Merkle Lockup contract.

```solidity
function createMerkleLL() public returns (ISablierMerkleLL merkleLL) {
  // ...
}
```

## Parameters

Merkle Factory uses
[MerkleBase.ConstructorParams](/reference/airdrops/contracts/types/library.MerkleBase#constructorparams) as the shared
struct among all the create functions.

```solidity
MerkleBase.ConstructorParams memory baseParams;
```

Let's review each parameter of the shared struct in detail.

### Cancelable

Boolean that indicates whether the stream will be cancelable or not after it has been claimed.

```solidity
baseParams.cancelable = false;
```

### Expiration

The unix timestamp indicating the expiration of the campaign. Once this time has been passed, users will no longer be
able to claim their airdrop. And you will be able to
[clawback](/reference/airdrops/contracts/abstracts/abstract.SablierMerkleBase#clawback) any unclaimed tokens from the
campaign.

```solidity
baseParams.expiration = uint40(block.timestamp + 12 weeks);
```

### Initial Admin

This is the initial admin of the Airstream campaign. When a recipient claims his airdrop, a Lockup stream is created
with this admin as the sender of the stream. Another role of admin is to clawback unclaimed tokens from the campaign
post expiry and during grace period.

```solidity
baseParams.initialAdmin = address(0xBeeF);
```

### IPFS CID

This is the content identifier (CID) for indexing the contract on IPFS. This is where we store addresses of the Airdrop
recipients and their claim amount.

```solidity
baseParams.ipfsCID = "QmT5NvUtoM5nWFfrQdVrFtvGfKFmG7AHE8P34isapyhCxX";
```

### Merkle Root

These campaigns use a Merkle tree data structure to store the airdrop data onchain. As a result, you only pay the gas
fee to create the contract and store the Merkle root onchain. Airdrop recipients can then call the contract on their own
to claim their airdrop.

If you want to create the Merkle root programmatically, you can follow
[our guide on Merkle API](/api/airdrops/merkle-api/overview).

```solidity
baseParams.merkleRoot = 0x4e07408562bedb8b60ce05c1decfe3ad16b722309875f562c03d02d7aaacb123;
```

### Name

The name of the campaign.

```solidity
baseParams.name = "My First Campaign";
```

### Token

The contract address of the ERC-20 token that you want to airdrop to your recipients. In this example, we will use DAI.

```solidity
baseParams.token = DAI;
```

### Transferable

Boolean that indicates whether the stream will be transferable or not. This is the stream that users obtain when they
claim their airstream.

```solidity
baseParams.transferable = true;
```

Now that we have the `baseParams` ready, it's time to setup rest of the input parameters.

### Aggregate Amount

This is the total amount of tokens you want to airdrop to your users, denoted in units of the asset's decimals. Let say
you want to airdrop 100M tokens of DAI. Then, the aggregate amount would be $100Mm*10^{18}$.

```solidity
uint256 aggregateAmount = 100000000e18;
```

### Recipient Count

The total number of recipient addresses.

```solidity
uint256 recipientCount = 10000;
```

### Schedule

For the Lockup Linear campaign, a new struct named `Schedule` is needed. This structure enables the configuration of
various requirements for the campaign creator. For this example, we will have the following configurations:

1. `startTime`: sets the start time of vesting. If set to 0, the vesting will begin at the time of claim.
2. `startPercentage`: We want to unlock 0.01% of the total amount at the start time.
3. `cliffDuration`: We want a cliff duration of 30 days.
4. `cliffPercentage`: We want to unlock another 0.01% after the cliff period ends.
5. `totalDuration`: The total duration of vesting should be 90 days.

```solidity
MerkleLL.Schedule memory schedule = MerkleLL.Schedule({
    startTime: 0,
    startPercentage: ud2x18(0.01e18),
    cliffDuration: 30 days,
    cliffPercentage: ud2x18(0.01e18),
    totalDuration: 90 days
});
```

## Invoke the create function

With all parameters set, we can now call the `createMerkleLL` function, and assign the address of the newly created
campaign to a variable:

```solidity
merkleLL = FACTORY.createMerkleLL({
  baseParams: baseParams,
  lockup: LOCKUP,
  cancelable: false,
  transferable: true,
  schedule: schedule,
  aggregateAmount: aggregateAmount,
  recipientCount: recipientCount
});

```

## Full code

Below you can see the full code. You can also access the code on GitHub through
[this link](https://github.com/sablier-labs/examples/blob/main/airdrops/MerkleCreator.sol).

```solidity reference title="Merkle Campaign Creator"
https://github.com/sablier-labs/examples/blob/main/airdrops/MerkleCreator.sol
```

================
File: docs/guides/flow/examples/01-local-environment.mdx
================
---
id: "local-environment"
sidebar_position: 1
title: "Configure Your Local Environment"
---

import {
  Introduction,
  Prerequisite,
  SetupWithTemplate,
  SetupWithFoundry,
  InstallNpm,
  FirstContract1,
  FirstContract2,
  RunForkTest1,
  RunForkTest2,
  FinalSteps,
} from "@site/src/snippets/LocalEnvironment.mdx";

<Introduction protocol="Flow" />

## Pre-requisites

<Prerequisite />

## Set up using Flow integration template

:::tip

Make sure you are using the latest version of Foundry by running `foundryup`.

:::

<SetupWithTemplate protocol="Flow" />

## Set up using Foundry template

<SetupWithFoundry protocol="Flow" />

:::note

You might notice that the CLI is `forge` rather than `foundry`. This is because Foundry is a toolkit, and `forge` is
just one of the tools that comes with it.

:::

## Install Flow npm package

<InstallNpm protocol="Flow" />

## Write your first contract

<FirstContract1 />

```solidity reference title="Flow Stream Creator"
https://github.com/sablier-labs/flow-integration-template/blob/main/src/FlowStreamCreator.sol
```

<FirstContract2 />

:::info

The minimum Solidity version supported by the Flow contracts is v0.8.22.

:::

## Run a fork test

<RunForkTest1 />

```solidity reference title="Flow Stream Creator Test"
https://github.com/sablier-labs/flow-integration-template/blob/main/test/FlowStreamCreator.t.sol
```

<RunForkTest2 protocol="Flow" />

## Next steps

<FinalSteps protocol="Flow" />

================
File: docs/guides/flow/examples/02-calculate-rps.mdx
================
---
id: "flow-calculate-rps"
sidebar_position: 2
title: "Calculate Rate per Second"
---

import AdmonitionSimpleCode from "@site/src/snippets/AdmonitionSimpleCode.mdx";

This guide explains how to calculate the rate per second when creating a Flow stream. It is the most important step in
setting up a stream since the rate per second is a key parameter in the stream's configuration.

We assume that you have already gone through the [Protocol Concepts](/concepts/streaming) and the
[Flow Overview](/concepts/flow/overview) sections.

<AdmonitionSimpleCode />

The rate per second is the amount of tokens streamed in one second. It is represented as a fixed-point number with 18
decimals, specifically as a `UD21x18` type from the `PRBMath` library. The underlying native Solidity type associated
with `UD21x18` is `uint128`.

Depending on how you receive payments, you have to calculate the rate per second and scale its value to 18 decimals
format as below:

1. Based on a duration, e.g., 3 months
2. Between two points in time, e.g., January 1, 2025 to April, 1 2025

The calculation method is the same in either case.

## Set up a library

Declare the Solidity version used to compile the library:

```solidity
pragma solidity >=0.8.22;
```

Import the relevant symbols:

```solidity
import { IERC20Metadata } from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
import { ud21x18, UD21x18 } from "@prb/math/src/UD21x18.sol";
```

Declare a library that can be used in other contracts:

```solidity
library FlowUtilities {}
```

## Calculate the rate per second on a duration

Define a function called `ratePerSecondWithDuration` that takes the following parameters and the returned value:

```solidity
function ratePerSecondWithDuration(
    address token,
    uint128 amount,
    uint40 duration
)
    internal
    view
    returns (UD21x18 ratePerSecond)
{
    // ...
}
```

First, retrieve the token's decimals. Note that not all ERC-20 tokens use the 18-decimal standard.

```solidity
uint8 decimals = IERC20Metadata(token).decimals();
```

If the token uses 18 decimals, simply divide the amount by the duration:

```solidity
if (decimals == 18) {
    return ud21x18(amount / duration);
}
```

If the token has less than 18 decimals, calculate the scale factor from the token's decimals:

```solidity
uint128 scaleFactor = uint128(10 ** (18 - decimals));
```

Then, multiply the amount by the scale factor and divide it by the duration:

```solidity
return ud21x18((amount * scaleFactor) / duration);
```

## Calculate the rate per second on timestamps

Here, there are two time parameters, a start and an end time, instead of a duration. Let's define the function:

```solidity
function ratePerSecondForTimestamps(
    address token,
    uint128 amount,
    uint40 start,
    uint40 end
)
    internal
    view
    returns (UD21x18 ratePerSecond)
{
    // ...
}
```

The first step is to calculate the duration between the two timestamps:

```solidity
uint40 duration = end - start;
```

The remaining logic is identical to the duration-based calculation:

```solidity
uint8 decimals = IERC20Metadata(token).decimals();

if (decimals == 18) {
    return ud21x18(amount / duration);
}

uint128 scaleFactor = uint128(10 ** (18 - decimals));

ratePerSecond = ud21x18((scaleFactor * amount) / duration);
```

## Additional utilities

To calculate earnings for specific durations from an existing stream, you can use the following functions:

```solidity
function calculateAmountStreamedPerWeek(UD21x18 ratePerSecond) internal pure returns (uint128 amountPerWeek) {
    amountPerWeek = ratePerSecond.unwrap() * 1 weeks;
}

function calculateAmountStreamedPerMonth(UD21x18 ratePerSecond) internal pure returns (uint128 amountPerMonth) {
    amountPerMonth = ratePerSecond.unwrap() * 30 days;
}

function calculateAmountStreamedPerYear(UD21x18 ratePerSecond) internal pure returns (uint128 amountPerYear) {
    amountPerYear = ratePerSecond.unwrap() * 365 days;
}
```

## Full code

Below you can see the complete `FlowUtilities` library:

```solidity reference title="Flow Utilities library"
https://github.com/sablier-labs/examples/blob/main/flow/FlowUtilities.sol
```

================
File: docs/guides/flow/previous-deployments/v1.0.mdx
================
---
id: "v1.0"
sidebar_position: 3
title: "v1.0"
---

import DeploymentsV1_0 from "@site/src/autogen/flow/TableDeploymentsV1.0.mdx";

# Flow v1.0

This section contains the deployment addresses for the v1.0 release of
[@sablier/flow@1.0.0](https://npmjs.com/package/@sablier/flow/v/1.0.0).

A few noteworthy details about the deployments:

- The addresses are final
- All contracts are non-upgradeable
- The source code is verified on Etherscan across all chains

:::info

This is an outdated version of the Flow protocol. See the latest version [here](/guides/flow/deployments).

:::

<DeploymentsV1_0 />

================
File: docs/guides/flow/04-gas-benchmarks.mdx
================
---
id: "gas-benchmarks"
sidebar_position: 4
title: "Gas Benchmarks"
---

import Link from "@docusaurus/Link";
import RemoteGFMContent from "@site/src/components/atoms/RemoteGFMContent";
import { Links } from "@site/src/constants";
import { getBenchmarkURL } from "@site/src/helpers";

The gas usage of the Flow protocol is not deterministic and varies by user. Calls to third-party contracts, such as
ERC-20 tokens, may use an arbitrary amount of gas. The values in the table below are rough estimations on Ethereum
mainnet - you shouldn't take them for granted. The gas usage may vary depending on the network.

:::note

The benchmarks were generated using the code in this <Link href={Links.GitHub.BENCHMARKS}>GitHub repository</Link>.

:::

## SablierFlow

<RemoteGFMContent url={getBenchmarkURL("results/flow/flow.md")} />

================
File: docs/guides/legacy/03-codebase.mdx
================
---
id: codebase
title: Codebase
sidebar_position: 5
---

import LinkPreview from "@site/src/components/molecules/LinkPreview";

## Repository

The Sablier Legacy code is hosted on GitHub and the source code for each contract is verified on Etherscan.

<LinkPreview
  href="https://github.com/sablier-labs/legacy"
  icon="github"
  subtitle="GitHub"
  title="Github - sablier-labs/sablier: Sablier Legacy protocol"
/>

## ABIs

Depending on the web3 library you're working with, you may need to get hold of the Lockup ABIs (application binary
interfaces). The ABI acts as an interface between two program modules, one of which is the smart contract and the other
the Ethereum virtual machine code.

There are two ways to obtain it:

1. Copy `Sablier.json` from [sablier-labs/legacy-abis](https://github.com/sablier-labs/legacy-abis).
2. Clone [sablier-labs/legacy](https://github.com/sablier-labs/legacy) and compile the contract yourself.

Here's an example for how to do step 2 with yarn and truffle:

```bash
$ git clone git@github.com/sablier-labs/legacy.git sablier-legacy
$ cd ./sablier-legacy
$ yarn bootstrap
$ cd ./packages/protocol
$ truffle compile

The `Sablier.json` artifact should be generated in the relative `build/contracts` folder.
```

================
File: docs/guides/lockup/examples/01-local-environment.mdx
================
---
id: "local-environment"
sidebar_position: 1
title: "Configure Your Local Environment"
---

import {
  Introduction,
  Prerequisite,
  SetupWithTemplate,
  SetupWithFoundry,
  InstallNpm,
  FirstContract1,
  FirstContract2,
  RunForkTest1,
  RunForkTest2,
  FinalSteps,
} from "@site/src/snippets/LocalEnvironment.mdx";

<Introduction protocol="Lockup" />

## Pre-requisites

<Prerequisite />

## Set up using Lockup integration template

:::tip

Make sure you are using the latest version of Foundry by running `foundryup`.

:::

<SetupWithTemplate protocol="Lockup" />

## Set up using Foundry template

<SetupWithFoundry protocol="Lockup" />

:::note

You might notice that the CLI is `forge` rather than `foundry`. This is because Foundry is a toolkit, and `forge` is
just one of the tools that comes with it.

:::

## Install Lockup npm packages

<InstallNpm protocol="Lockup" />

## Write your first contract

<FirstContract1 />

```solidity reference title="Lockup Stream Creator"
https://github.com/sablier-labs/lockup-integration-template/blob/main/src/LockupStreamCreator.sol
```

<FirstContract2 />

:::info

The minimum Solidity version supported by the Lockup contracts is v0.8.22.

:::

## Run a fork test

<RunForkTest1 />

```solidity reference title="Lockup Stream Creator Test"
https://github.com/sablier-labs/lockup-integration-template/blob/main/test/LockupStreamCreator.t.sol
```

<RunForkTest2 protocol="Lockup" />

## Next steps

<FinalSteps protocol="Lockup" />

================
File: docs/guides/lockup/previous-deployments/v1.0.mdx
================
---
id: "v1.0"
sidebar_position: 3
title: "v1.0"
---

import DeploymentsV1_0 from "@site/src/autogen/lockup/TableDeploymentsV1.0.mdx";

# Lockup v1.0

This section contains the deployment addresses for the v1.0 release of [@sablier/v2-core@1.0.2][v2-core] and
[@sablier/v2-periphery@1.0.3][v2-periphery].

[v2-core]: https://npmjs.com/package/@sablier/v2-core/v/1.0.2
[v2-periphery]: https://npmjs.com/package/@sablier/v2-periphery/v/1.0.3

A few noteworthy details about the deployments:

- The addresses are final
- All contracts are non-upgradeable
- The source code is verified on Etherscan across all chains

:::info

This is an outdated version of the Lockup protocol. See the latest version [here](/guides/lockup/deployments).

:::

<DeploymentsV1_0 />

================
File: docs/guides/lockup/previous-deployments/v1.1.mdx
================
---
id: "v1.1"
sidebar_position: 2
title: "v1.1"
---

import DeploymentsV1_1 from "@site/src/autogen/lockup/TableDeploymentsV1.1.mdx";

# Lockup v1.1

This section contains the deployment addresses for the v1.1 release of [@sablier/v2-core@1.1.2][v2-core] and
[@sablier/v2-periphery@1.1.1][v2-periphery].

[v2-core]: https://npmjs.com/package/@sablier/v2-core/v/1.1.2
[v2-periphery]: https://npmjs.com/package/@sablier/v2-periphery/v/1.1.1

A few noteworthy details about the deployments:

- The addresses are final
- All contracts are non-upgradeable
- The source code is verified on Etherscan across all chains

:::info

This is an outdated version of the Lockup protocol. See the latest version [here](/guides/lockup/deployments).

:::

<DeploymentsV1_1 />

================
File: docs/guides/lockup/previous-deployments/v1.2.mdx
================
---
id: "v1.2"
sidebar_position: 1
title: "v1.2"
---

import DeploymentsV1_2 from "@site/src/autogen/lockup/TableDeploymentsV1.2.mdx";

# Lockup v1.2

This section contains the deployment addresses for the v1.2 release of [@sablier/v2-core@1.2.0][v2-core] and
[@sablier/v2-periphery@1.2.0][v2-periphery].

[v2-core]: https://npmjs.com/package/@sablier/v2-core/v/1.2.0
[v2-periphery]: https://npmjs.com/package/@sablier/v2-periphery/v/1.2.0

A few noteworthy details about the deployments:

- The addresses are final
- All contracts are non-upgradeable
- The source code is verified on Etherscan across all chains

:::info

This is an outdated version of the Lockup protocol. See the latest version [here](/guides/lockup/deployments).

:::

<DeploymentsV1_2 />

================
File: docs/guides/lockup/04-gas-benchmarks.mdx
================
---
id: "gas-benchmarks"
sidebar_position: 4
title: "Gas Benchmarks"
---

import Link from "@docusaurus/Link";
import RemoteGFMContent from "@site/src/components/atoms/RemoteGFMContent";
import { Links } from "@site/src/constants";
import { getBenchmarkURL } from "@site/src/helpers";

The gas usage of the Lockup protocol is not deterministic and varies by user. Calls to third-party contracts, such as
ERC-20 tokens, may use an arbitrary amount of gas. The values in the table below are rough estimations on Ethereum
mainnet - you shouldn't take them for granted. The gas usage may vary depending on the network.

:::note

The benchmarks were generated using the code in this <Link href={Links.GitHub.BENCHMARKS}>GitHub repository</Link>.

:::

## BatchLockup

<RemoteGFMContent url={getBenchmarkURL("results/lockup/batch-lockup.md")} />

## LockupLinear streams

<RemoteGFMContent url={getBenchmarkURL("results/lockup/lockup-linear.md")} />

## LockupDynamic streams

<RemoteGFMContent url={getBenchmarkURL("results/lockup/lockup-dynamic.md")} />

## LockupTranched streams

<RemoteGFMContent url={getBenchmarkURL("results/lockup/lockup-tranched.md")} />

================
File: docs/support/01-faq.mdx
================
---
id: "faq"
sidebar_position: 1
title: "FAQ"
---

### Where can I access the Sablier Protocol?

You can access Sablier through the following web interfaces:

- [app.sablier.com](https://app.sablier.com)
- [app.safe.global](https://app.safe.global/share/safe-app?appUrl=https%3A%2F%2Fapp.sablier.com%2F&chain=arb1) (if you
  are using a Safe multisig wallet)

### What is token streaming?

An alternative wording, coined by Andreas Antonopoulos in 2017. Just like you can stream movies on Netflix or music on
Spotify, so you can stream tokens by the second on Sablier.

### How does streaming work on Sablier Lockup?

Imagine Alice wants to stream 3000 DAI to Bob during the whole month of January.

1. Alice deposits the 3000 DAI in Lockup before Jan 1, setting the end time to Feb 1.
2. Bob's allocation of the DAI deposit increases every second beginning Jan 1.
3. On Jan 10, Bob will have earned approximately 1000 DAI. He can send a transaction to withdraw the tokens.
4. If at any point during January Alice wishes to get back her tokens, she can cancel the stream and recover what has
   not been streamed yet.

### How does Lockup calculate the payment rate?

Dividing the deposit amount by the difference between the stop time and the start time gives us a payment rate per
second. Lockup uses this rate to transfer a small portion of tokens from the sender to the recipient once every second.

For instance, if the payment rate was 0.01 DAI per second, the recipient would receive:

$0.01 * 60 = 0.6$ DAI / minute, $0.01 * 60 * 60 = 36$ DAI / hour, $0.01 * 60 * 60 * 24 = 864$ DAI / day

### How does streaming work on Sablier Flow?

Imagine Alice wants to stream 3000 DAI on a monthly basis to Bob.

1. Alice creates a stream on Flow with a rate of 3000 DAI per month.
2. Alice deposits 200 DAI in Flow.
3. On Jan 10, Bob is owed 1000 DAI, but there is only 200 DAI in the stream. So he can only withdraw 200 DAI.
4. Alice deposits another 2800 DAI in Flow, and Bob can now withdraw the remaining 800 DAI.
5. On Feb 1, Bob is able to withdraw 2800 DAI.
6. The stream will continue indefinitely until it is paused (by Alice) or voided (by either Alice or Bob).

### How can I create a stream?

You will need an EVM wallet (e.g. [Metamask](https://metamask.io), [Rainbow](https://rainbow.me), etc.), some ETH (or
the network's token to pay gas fees) and an ERC-20 token like DAI. Then, choose your favorite interface for accessing
the Sablier Protocol (such as [app.sablier.com](https://app.sablier.com)) and fill in the recipient's address, the
deposit amount and the total duration.

Alternatively, you can see [here](/guides/lockup/etherscan) how to manually create a stream using
[Etherscan](https://etherscan.io).

### Where are the tokens held?

In the Sablier smart contracts. You can verify this assertion by inspecting Etherscan or any other blockchain explorer.

### How can recipients access their tokens?

As the tokens are being streamed at the smart contract level, recipients can consider Sablier their real-time wallet for
digital currency.

To make withdrawals, recipients can:

1. Use a web interface (e.g. [app.sablier.com](https://app.sablier.com)).
2. Call the contract directly on a blockchain explorer.

### Can I cancel streams?

Yes, both as a sender and a recipient.

If the stream is canceled before the start time, the whole deposit amount is returned in full to you. If the stream is
canceled while the stream is active, the smart contracts calculate how much has been streamed, transfer that to the
recipient and return the remainder to you. If the stream is canceled after the stream has stopped, the smart contracts
transfers all the remaining funds (if any) to the recipient.

### Can I modify the streaming rate?

On Lockup, once a stream is created, it is set in stone on the Ethereum blockchain. Whereas on Flow, the streaming rate
per second can be adjusted anytime by the sender.

### How are vested airdrops different from a batch of normal streams?

Creating streams through the form (manual or CSV) will immediately start the vesting period. You click to create the
transaction, pay for the gas, and you start all the streams for your recipients.

Due to how block gas limits work, you can only fit a limited number of streams (usually 60) in a single block before
running out of space. This is great for small distributions like paying your contractors or a set of investors.

Meanwhile, vested airdrops leverage a "lazy creation" of streams. You deploy a contract that stores a list of recipients
and the streams they are entitles to claim. Every recipient will manually claim their allocation by creating a stream.
This allows for millions of recipients in your distribution campaign, with each recipient triggering the stream creation
one after the other (as opposed to all at once).

| Feature                        | Groups                           | Airdrops              |
| ------------------------------ | -------------------------------- | --------------------- |
| Maximum number of streams      | ~280 (different limit per chain) | Millions              |
| Gas to create streams          | Sender paying                    | Each recipient paying |
| Gas to deploy Airdrop contract | N/A                              | Sender paying         |
| Streams show up onchain        | Immediately                      | Lazily                |
| Good for                       | Investors, Employees             | Large communities     |

### What is real-time finance?

A term coined by us to emphasize the wide-ranging use cases for the Sablier Protocol. We like to think about work as an
attempt to rethink the way trust is established in financial contracts.

================
File: src/snippets/AdmonitionSimpleCode.mdx
================
:::caution

The code in this guide is not production-ready, and is implemented in a simplistic manner for the purpose of learning.

:::

================
File: src/snippets/BatchCommonSteps.mdx
================
## Function definition

Define a function called `batchCreateStreams` that takes a parameter `perStreamAmount` and returns an array of ids for
the created streams:

```solidity
function batchCreateStreams(uint128 perStreamAmount) public returns (uint256[] memory streamIds) {
  // ...
}
```

## Batch size

Next, declare a batch size, which is needed to calculate the transfer amount:

```solidity
// Create a batch of two streams
uint256 batchSize = 2;

// Calculate the combined amount of DAI to transfer to this contract
uint256 transferAmount = perStreamAmount * batchSize;
```

## ERC-20 steps

To create a stream, the caller must approve the creator contract to pull the tokens from the calling address's account.
Then, we have to also approve the `Batch` contract to pull the tokens that the creator contract will be in possession of
after they are transferred from the calling address (you):

```solidity
// Transfer the provided amount of DAI tokens to this contract
DAI.transferFrom(msg.sender, address(this), transferAmount);

// Approve the Batch contract to spend DAI
DAI.approve(address(BATCH_LOCKUP), transferAmount);
```

For more guidance on how to approve and transfer ERC-20 tokens, see
[this article](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/) on the Ethereum website.

================
File: src/snippets/DeprecatedIndexers.mdx
================
:::important

The following indexers were deprecated on February 3, 2025, so they might return outdated data if queried now. Please
use our latest endpoints to query up-to-date data for the Sablier Protocol.

:::

================
File: src/snippets/ExplainerEnvio.mdx
================
Envio is a multi-chain indexer. There's a single GraphQL API endpoint that aggregates data across chains. This approach differs from
other vendors like The Graph, which require a separate indexer for each chain where Sablier is available.

================
File: src/snippets/ExplainerTheGraph.mdx
================
import TabItem from "@theme/TabItem";
import Tabs from "@theme/Tabs";

In the table below, you will see three URLs:

- `Production URL`: requires a Studio API key for making queries.
- `Testing URL`: doesn't require an API key but it's rate-limited to 3000 queries per day. Opening this URL in the browser opens a GraphiQL playground.
- `Explorer URL`: The explorer URL for the indexer, if available.

To learn how to create a Studio API key, check out [this guide](https://thegraph.com/docs/en/studio/managing-api-keys).

The API key has to be provided via an `Authorization: Bearer <API_KEY>` header. Here are two examples in `curl` and JavaScript:

<Tabs>
<TabItem value="curl" label="curl">

```bash
curl -X POST \
  -H "Authorization: Bearer <API_KEY>" \
  -H "Content-Type: application/json" \
  -d '{"query": "{ _meta: { block { number } } }"' \
  <PRODUCTION_URL>
```

</TabItem>

<TabItem value="js" label="JavaScript">

```javascript
import { GraphQLClient } from "graphql-request";

async function getBlockNumber() {
  const client = new GraphQLClient("<PRODUCTION_URL>", {
    headers: {
      Authorization: `Bearer <API_KEY>`,
    },
  });

  const query = `query { _meta: { block { number } } }`;
  const result = await client.request(query);
  console.log(result);
}
```

</TabItem>
</Tabs>

================
File: src/snippets/LocalEnvironment.mdx
================
{/* eslint-disable react/prop-types */}

import Link from "@docusaurus/Link";

export const Introduction = ({ protocol }) => (
  <>
    In this guide, we will go through the steps to set up a local development environment for building onchain
    integrations with {protocol}. We will use Foundry to install {protocol} as a dependency, and run a simple test.
    <br />
    <br />
    At the end, youll have a development environment set up that you can use to build the rest of the examples under
    &quot;Guides&quot;, or start your own integration project.
  </>
);

export const Prerequisite = () => (
  <>
You will need the following software on your machine:

<br />
<br />

<ul>
  <li>
    <Link href="https://git-scm.com/downloads">Git</Link>
  </li>
  <li>
    <Link href="https://github.com/foundry-rs/foundry">Foundry</Link>
  </li>
  <li>
    <Link href="https://nodejs.org/en/download">Node.js</Link>
  </li>
  <li>
    <Link href="https://bun.sh">Bun</Link>
  </li>
</ul>

In addition, familiarity

with <Link href="https://ethereum.org/">Ethereum</Link> and <Link href="https://soliditylang.org/">Solidity</Link> is
requisite.

</>
);

export const SetupWithTemplate = ({ protocol }) => (
  <>

We put together a template repository that you can use to get started quickly. This repository features a basic project
structure, pre-configured {protocol} imports, and a selection of sample contracts and tests.

<br />
<br />

To install the template, simply execute the following commands:

<br />
<br />

<pre>
  <code>
    $ mkdir {protocol.toLowerCase()}-integration-template
    <br />$ cd {protocol.toLowerCase()}-integration-template
    <br />$ forge init --template sablier-labs/{protocol.toLowerCase()}-integration-template
    <br />$ bun install
  </code>
</pre>

Then, hop to the <Link href="#run-a-fork-test">Run a Fork Test</Link> section to complete your set up and start
developing.

</>
);

export const SetupWithFoundry = ({ protocol }) => (
<>
Foundry is a popular development toolkit for Ethereum projects, which we have used to build the {protocol} Protocol. For
the purposes of this guide, Foundry will provide us with the tooling needed to compile and test our contracts.

<br />
<br />

Let&apos;s use this command to spin up a new Foundry project:

<br />
<br />

<pre>
  <code>
    $ forge init my-project
    <br />$ cd my-project
  </code>
</pre>

Once the initialization completes, take a look around at what got set up:

<br />
<br />

<pre>
  <code>
     foundry.toml
    <br />
     script
    <br />
     src
    <br />
     test
  </code>
</pre>

The folder structure should be intuitive:

<br />
<br />

<ul>
  <li>
    <code>src</code> is where you&apos;ll write Solidity contracts
  </li>
  <li>
    <code>test</code> is where you&apos;ll write tests (also in Solidity)
  </li>
  <li>
    <code>script</code> is where you&apos;ll write scripts to perform actions like deploying contracts (you guessed it,
    in Solidity)
  </li>
  <li>
    <code>foundry.toml</code> is where you can configure your Foundry settings, which we will leave as is in this guide
  </li>
</ul>

</>
);

export const InstallNpm = ({ protocol }) => (
  <>

Let&apos;s install the {protocol} Node.js packages using Bun:

<br />
<br />

<pre>
  <code>
    $ bun add @sablier/{protocol.toLowerCase()}
    <br />
  </code>
</pre>

Bun will download the {protocol} contracts, along with their dependencies,

and put them in the <code>node_modules</code> directory.

<br />
<br />

Let&apos;s remap the package names to point to the installed contracts. This step is required so that the Solidity
compiler can find the {protocol} contracts when you import them:

<br />
<br />

<pre>
  <code>
    $ echo &quot;@sablier/{protocol.toLowerCase()}=node_modules/@sablier/{protocol.toLowerCase()}/&quot; &gt;&gt;
    remappings.txt
    <br />$ echo &quot;@openzeppelin/contracts/=node_modules/@openzeppelin/contracts/&quot; &gt;&gt; remappings.txt
    <br />$ echo &quot;@prb/math/=node_modules/@prb/math/&quot; &gt;&gt; remappings.txt
  </code>
</pre>

That&apos;s it! You should now have a functional development environment to start building onchain {protocol}
integrations. Let&apos;s run a quick test to confirm everything is set up properly.

      </>

);

export const FirstContract1 = () => (
  <>
Delete the <code>src/Counter.sol</code> and <code>test/Counter.t.sol</code> files generated by Forge, and create two new files:
<br />
<code>src/StreamCreator.sol</code> and <code>test/StreamCreator.t.sol</code>.

<br />
<br />

Paste the following code into <code>src/StreamCreator.sol</code>:

<br />
<br />

</>
);

export const FirstContract2 = () => (
  <>

Let&apos;s use Forge to compile this contract:

<pre>
  <code>
    $ forge build
    <br />
  </code>
</pre>

If the contract was compiled correctly, you should see this message:

<pre>
  <code>
    [] Compiling...
    <br />
    [] Compiling 62 files with Solc 0.8.26
    <br />
    [] Solc 0.8.26 finished in 967.04ms
    <br />
    Compiler run successful!
  </code>
</pre>

  </>

);

export const RunForkTest1 = () => (
  <>
Foundry offers native support for running tests against a fork of Ethereum Mainnet, testnets and L2s, which is useful
when building and testing integrations with onchain protocols like Sablier. In practice, this enables you to access all
Sablier contracts deployed on Ethereum, and use them for testing your integration.

<br />
<br />

As a prerequisite, you will need an RPC that supports forking.

A good solution for this is <Link href="https://alchemy.com/">Alchemy</Link>, as it includes forking in its free tier
plan.

<br />
<br />

Once you have obtained your RPC, you can proceed to run the following test:

<br />
<br />

  </>

);

export const RunForkTest2 = ({ protocol }) => (
  <>
You can run the test using Forge:

<br />
<br />

<pre>
  <code>
    $ forge test
    <br />
  </code>
</pre>

If the test passed, you should see a message like this:

<br />
<br />

<pre>
  <code>
    Ran 2 tests for test/{protocol}StreamCreator.t.sol:{protocol}StreamCreatorTest
    <br />
    [PASS] test_Create{protocol}Stream() (gas: 246830)
    <br />
    Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 626.58ms (500.67s CPU time)
    <br />
  </code>
</pre>

  </>

);

export const FinalSteps = ({ protocol }) => (
  <>
Congratulations! Your environment is now configured, and you are prepared to start building. Explore the guides section
to discover various features available for {protocol} integration. Remember to include all contracts (<code>.sol</code> files) in the <code>src</code>
folder and their corresponding tests in the <code>test</code> folder.

<br />
<br />

As far as Foundry is concerned, there is much more to uncover. If you want to learn more about it,

check out the <Link href="https://book.getfoundry.sh/">Foundry Book</Link>, which contains numerous examples and
tutorials. A deep understanding of Foundry will enable you to create more sophisticated integrations

with {protocol} protocol.

  </>

);

================
File: src/snippets/LockupParams.mdx
================
Let's review each parameter in detail.

### Broker

An optional parameter that can be set in order to charge a fee as a percentage of `totalAmount`.

In the following example, we will leave this parameter uninitialized (i.e. set to zero), because it doesn't make sense
to charge yourself a fee. In practice, this parameter will mostly be used by front-end applications.

```solidity
params.broker = Broker(address(0), ud60x18(0));
```

:::info

Wondering what's up with that `ud60x18` function? It's a casting function that wraps a basic integer to the `UD60x18`
value type. This type is part of the math library [PRBMath](https://github.com/PaulRBerg/prb-math), which is used in
Sablier for fixed-point calculations.

:::

### Cancelable

Boolean that indicates whether the stream will be cancelable or not.

```solidity
params.cancelable = true;
```

### Recipient

The address receiving the tokens:

```solidity
params.recipient = address(0xCAFE);
```

### Sender

The address streaming the tokens, with the ability to cancel the stream:

```solidity
params.sender = msg.sender;
```

### Token

The contract address of the ERC-20 token used for streaming. In this example, we will stream DAI:

```solidity
params.token = DAI;
```

### Total amount

The total amount of ERC-20 tokens to be paid, including the stream deposit and any potential [fees](/concepts/fees), all
denoted in units of the asset's decimals.

```solidity
params.totalAmount = totalAmount;
```

### Transferable

Boolean that indicates whether the stream will be transferable or not.

```solidity
params.transferable = true;
```

================
File: src/snippets/ReleaseHistoryAirdrops.mdx
================
| Version                           | Release Date  |
| --------------------------------- | ------------- |
| [v1.3](/guides/airdrops/overview) | February 2025 |

================
File: src/snippets/ReleaseHistoryFlow.mdx
================
| Version                                        | Release Date  | UI Aliases |
| ---------------------------------------------- | ------------- | ---------- |
| [v1.1](/guides/flow/overview) (latest)         | February 2025 | FL2        |
| [v1.0](/guides/flow/previous-deployments/v1.0) | December 2024 | FL         |

================
File: src/snippets/ReleaseHistoryLegacy.mdx
================
| Version                            | Release Date  |
| ---------------------------------- | ------------- |
| [v1.1](/guides/legacy/deployments) | July 2021     |
| [v1.0](/guides/legacy/deployments) | November 2019 |

================
File: src/snippets/ReleaseHistoryLockup.mdx
================
| Version                                          | Release Date  | UI Aliases                                                             |
| ------------------------------------------------ | ------------- | ---------------------------------------------------------------------- |
| [v2.0](/guides/lockup/deployments) (latest)      | February 2025 | `LK` (Lockup): all models have been merged into a single contract      |
| [v1.2](/guides/lockup/previous-deployments/v1.2) | July 2024     | `LD3` (Lockup Dynamic), `LL3` (Lockup Linear), `LT3` (Lockup Tranched) |
| [v1.1](/guides/lockup/previous-deployments/v1.1) | December 2023 | `LD2` (Lockup Dynamic), `LL2` (Lockup Linear)                          |
| [v1.0](/guides/lockup/previous-deployments/v1.0) | July 2023     | `LD` (Lockup Dynamic), `LL` (Lockup Linear)                            |

================
File: src/snippets/TokenApproval.mdx
================
## ERC-20 steps

To create a stream, the caller must approve the creator contract to pull the tokens from the calling address's account.
Then, we have to approve the Lockup contract to pull the tokens that the creator contract will be in possession of after
they are transferred from the calling address (you):

```solidity
// Transfer the provided amount of DAI tokens to this contract
DAI.transferFrom(msg.sender, address(this), totalAmount);

// Approve the Sablier contract to spend DAI
DAI.approve(address(LOCKUP), totalAmount);
```

For more guidance on how to approve and transfer ERC-20 tokens, see
[this article](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/) on the Ethereum website.

================
File: docs/apps/03-branding.mdx
================
---
id: "branding"
sidebar_position: 3
title: "Branding"
---

import LinkPreview from "@site/src/components/molecules/LinkPreview";

## Brand Guidelines

Want to make an integration with Sablier or just spread the word about it? We've put together a repository with all the
branding assets you need to get started.

If you have any special requests, reach out on [Discord](https://discord.sablier.com).

<LinkPreview
  href="https://github.com/sablier-labs/branding"
  icon="github"
  subtitle="GitHub"
  title="Github - sablier-labs/branding: Sablier brand guidelines and assets"
/>

================
File: docs/concepts/08-nft.mdx
================
---
id: "nft"
sidebar_position: 8
title: "NFTs"
---

import Link from "@docusaurus/Link";
import { Links } from "@site/src/constants";
import FlowNFTSVG from "@site/static/img/nft/flow.svg";
import LockupNFTGalleryURL from "@site/static/img/nft/gallery.webp";
import LockupNFTSVG from "@site/static/img/nft/lockup.svg";

Both Lockup and Flow Protocols wrap every stream in an ERC-721 non-fungible token (NFT), making the stream recipient the
owner of the NFT. The recipient can transfer the NFT to another address, and this also transfers the right to withdraw
funds from the stream, including any funds already streamed.

## Lockup NFT

Sablier Lockup streams are represented as unique onchain generated hourglass SVGs, which change their color and content
based on user data. Here's an example for a stream that is 42.35% way through:

<LockupNFTSVG height={500} width={500} />

### Gallery of Multiple Sablier NFT SVGs

<img src={LockupNFTGalleryURL} height={500} width={500} />

If you prefer the granularity of a blockchain explorer, you can also view the stream NFTs on
[Etherscan](https://etherscan.io/token/0xB10daee1FCF62243aE27776D7a92D39dC8740f95). See the
[Deployments](/guides/lockup/deployments) page for the full list of addresses.

## Flow NFT

Unlike Lockup streams, the first release of Flow streams are represented by Sablier Logo.

<FlowNFTSVG height={500} width={500} />

## Integrations

The transferability of the NFT makes Sablier streams tradable and usable as collateral in DeFi. Imagine an NFT lending
marketplace that allows users to borrow funds by locking their streams as collateral (effectively borrowing against
their future income). Or a decentralized exchange that allows users to trade streams for other tokens.

:::note

Not all Sablier streams are transferable. The stream creator can choose to make the stream non-transferable. You can
find more details on it in the [Transferability](/concepts/transferability) section.

:::

:::info

If you're interested in making an integration, please fill out this <Link href={Links.Forms.CALL}>form</Link> and we
will try to respond as soon as possible.

:::

## Marketplaces

:::caution

Be careful when buying Lockup NFTs that represent cancelable stream. When these streams are canceled, the unstreamed
amount is returned to the sender.

:::

Thanks to adhering to the ERC-721 standard, Sablier streams can be traded and viewed on any NFT marketplace. Here are
some of the marketplaces that support Sablier streams:

- [OpenSea](https://opensea.io)
- [Blur](https://blur.io)
- [Rarible](https://rarible.com)
- [SuperRare](https://superrare.com)
- [LooksRare](https://looksrare.org)

## Caching

The SVG artwork is generated using certain real-time values, such as the current time on the blockchain. However, NFT
marketplaces cache the NFT metadata, and this may cause the SVGs might not always be up to date.

The Sablier Protocol triggers [ERC-4906](https://eips.ethereum.org/EIPS/eip-4906) events whenever there's an update in a
stream (for instance, when a withdrawal is made). However, some streams might remain unchanged for an extended period.

To ensure you're viewing the most recent version of the NFT SVG, it's recommended to check the stream directly via the
[Sablier Interface](https://app.sablier.com).

================
File: docs/guides/flow/examples/03-create-stream.mdx
================
---
id: "create-stream"
sidebar_position: 3
title: "Create a Stream"
---

import HardcodedDemonstration from "@site/src/components/atoms/HardcodedDemonstration";
import AdmonitionSimpleCode from "@site/src/snippets/AdmonitionSimpleCode.mdx";

# Create a Flow stream

In this guide, we will show you how you can create a Flow stream using Solidity.

It is important to note that A Flow stream has no end date, which means it will continue to accumulate debt even if no
funds are deposited.

This guide assumes that you have already gone through the [Calculate Rate per Second](./02-calculate-rps.mdx) section.

<AdmonitionSimpleCode />

## Set up a contract

Declare the Solidity version used to compile the contract:

```solidity
pragma solidity >=0.8.22;
```

Import the relevant symbols from `@sablier/flow`, and the `FlowUtilities` library:

```solidity
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { UD21x18 } from "@prb/math/src/UD21x18.sol";
import { ISablierFlow } from "@sablier/flow/src/interfaces/ISablierFlow.sol";

import { FlowUtilities } from "./FlowUtilities.sol";
```

Create a contract called `FlowStreamCreator`, and declare a constant `USDC` of type `IERC20` and a constant `FLOW` of
type `ISablierFlow`:

```solidity
contract FlowStreamCreator {
    IERC20 public constant USDC = IERC20(0xf08A50178dfcDe18524640EA6618a1f965821715);
    ISablierFlow public constant FLOW = ISablierFlow(0x52ab22e769E31564E17D524b683264B65662A014);
}
```

<HardcodedDemonstration protocol="Flow" />

We will declare two functions, based on the amount desired to stream over a period of time.

## Define a function

Define a function to stream a salary of 1000 USDC per month, call it `createStream_1K_PerMonth` which returns the newly
created stream ID:

```solidity
function createStream_1K_PerMonth() external returns (uint256) {
    // ...
}
```

## Input parameters

### Rate Per Second

Use the [`FlowUtilities`](./02-calculate-rps.mdx) library to calculate the rate per second for the desired amount:

```solidity
UD21x18 ratePerSecond = FlowUtilities.ratePerSecondWithDuration({ token: address(USDC), amount: 1000e6, duration: 30 days });
```

### Sender

The address streaming the tokens, with the ability to `pause` the stream:

```solidity
sender = msg.sender
```

### Recipient

The address receiving the tokens:

```solidity
recipient = address(0xCAFE);
```

### Token

The contract address of the ERC-20 token used for streaming. In this example, we will stream `USDC`:

```solidity
token = USDC;
```

### Transferable

Boolean that indicates whether the stream will be transferable or not.

```solidity
transferable = true;
```

### Invoke the create function

With all the parameters, we can call the `create` function on the `FLOW` contract and assign the newly created stream to
`streamId` variable:

```solidity
streamId = FLOW.create({
    sender: msg.sender,
    recipient: address(0xCAFE),
    ratePerSecond: FlowUtilities.ratePerSecondWithDuration({ token: address(USDC), amount: 1000e6, duration: 30 days }),
    token: USDC,
    transferable: true
});
```

## Full code

Below you can see the complete `FlowStreamCreator` contract:

```solidity reference title="Flow Stream Creator"
https://github.com/sablier-labs/examples/blob/main/flow/FlowStreamCreator.sol
```

================
File: docs/guides/flow/examples/05-batchable.mdx
================
---
id: "batchable"
sidebar_position: 5
title: "Batching Functions"
---

import HardcodedDemonstration from "@site/src/components/atoms/HardcodedDemonstration";
import AdmonitionSimpleCode from "@site/src/snippets/AdmonitionSimpleCode.mdx";

A neat feature of Sablier Flow is the ability to batch multiple function calls into a single transaction. This is made
possible by the [`Batch`](/reference/flow/contracts/abstracts/abstract.Batch) contract, which is inherited by
`SablierFlow`. With this, you can efficiently batch multiple function calls in a single transaction.

<AdmonitionSimpleCode />

## Set up a contract

Declare the Solidity version used to compile the contract:

```solidity
pragma solidity >=0.8.22;
```

Import the relevant symbols:

```solidity
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ud21x18, UD21x18 } from "@prb/math/src/UD21x18.sol";
import { ud60x18 } from "@prb/math/src/UD60x18.sol";
import { Broker, ISablierFlow } from "@sablier/flow/src/interfaces/ISablierFlow.sol";
```

Create a contract called `FlowBatchable`, and declare a constant `USDC` of type `IERC20` and a constant `FLOW` of type
`ISablierFlow`:

```solidity
contract FlowBatchable {
    IERC20 public constant USDC = IERC20(0xf08A50178dfcDe18524640EA6618a1f965821715);
    ISablierFlow public constant FLOW = ISablierFlow(0x52ab22e769E31564E17D524b683264B65662A014);
}
```

<HardcodedDemonstration protocol="Flow" />

## Create multiple streams

One of the most useful features achieved by `batch` is the ability to create multiple streams in a single transaction.
Let's focus on it in this example.

Define a function that creates multiple streams and returns their respective stream IDs:

```solidity
function createMultiple() external returns (uint256[] memory streamIds) {
    // ...
}
```

### Parameters

We will create two streams with same stream parameters required by the `create` function.

```solidity
address sender = msg.sender;
address firstRecipient = address(0xCAFE);
address secondRecipient = address(0xBEEF);
UD21x18 firstRatePerSecond = ud21x18(0.0001e18);
UD21x18 secondRatePerSecond = ud21x18(0.0002e18);
bool transferable = true;
```

Construct an array of `bytes` of length 2 to be passed into the `batch` function:

```solidity
bytes[] memory calls = new bytes[](2);
calls[0] = abi.encodeCall(FLOW.create, (sender, firstRecipient, firstRatePerSecond, USDC, transferable));
calls[1] = abi.encodeCall(FLOW.create, (sender, secondRecipient, secondRatePerSecond, USDC, transferable));
```

Since we are creating two streams, the function will return an array containing the two generated stream IDs:

```solidity
uint256 nextStreamId = FLOW.nextStreamId();
streamIds = new uint256[](2);
streamIds[0] = nextStreamId;
streamIds[1] = nextStreamId + 1;
```

Execute the `batch`:

```solidity
FLOW.batch(calls);
```

## Homework

Try to implement the following ideas using `batch` function:

- Adjust Rate Per Second and Deposit
- Pause and Withdraw Max
- Void and Withdraw Max
- Multiple Withdraw Max

Below, you will find the full code for it.

## Other ideas

There are plenty of other possibilities as well! Feel free to experiment and come up with combinations that suit your
system. 

## Full code

Below you can see the complete `FlowBatchable` contract:

```solidity reference title="Flow Batchable"
https://github.com/sablier-labs/examples/blob/main/flow/FlowBatchable.sol
```

================
File: docs/guides/lockup/examples/batch-create-streams/01-batch-lockup-linear.mdx
================
---
id: "batch-lockup-linear"
sidebar_position: 1
title: "Batch Lockup Linear"
---

import HardcodedDemonstration from "@site/src/components/atoms/HardcodedDemonstration";
import AdmonitionSimpleCode from "@site/src/snippets/AdmonitionSimpleCode.mdx";
import BatchCommonSteps from "@site/src/snippets/BatchCommonSteps.mdx";

# Create a Batch of Linear Streams

In this guide, we will show you how you can use Solidity to batch create linear streams via the
[Batch Lockup](/reference/lockup/contracts/contract.SablierBatchLockup) contract.

This guide assumes that you have already gone through the [Protocol Concepts](/concepts/streaming) section.

<AdmonitionSimpleCode />

## Set up a contract

Declare the Solidity version used to compile the contract:

```solidity
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity >=0.8.22;
```

Now, import the relevant symbols from `@sablier/lockup`:

```solidity
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ud60x18 } from "@prb/math/src/UD60x18.sol";
import { ISablierLockup } from "@sablier/lockup/src/interfaces/ISablierLockup.sol";
import { Broker, LockupLinear } from "@sablier/lockup/src/types/DataTypes.sol";
import { ISablierBatchLockup } from "@sablier/lockup/src/interfaces/ISablierBatchLockup.sol";
import { BatchLockup } from "@sablier/lockup/src/types/DataTypes.sol";
```

Create a contract called `BatchLLStreamCreator`, and declare a constant `DAI` of type `IERC20`, a constant `LOCKUP` of
type `ISablierLockup`, and a constant `BATCH_LOCKUP` of type `ISablierBatchLockup`:

```solidity
contract BatchLLStreamCreator {
    IERC20 public constant DAI = IERC20(0x68194a729C2450ad26072b3D33ADaCbcef39D574);
    ISablierLockup public constant LOCKUP = ISablierLockup(0xC2Da366fD67423b500cDF4712BdB41d0995b0794);
    ISablierBatchLockup public constant BATCH_LOCKUP = ISablierBatchLockup(0xd4294579236eE290668c8FdaE9403c4F00D914f0);
}
```

<HardcodedDemonstration protocol="Lockup" />

## Batch create functions

There are two batch create functions for the Linear streams:

- [`createWithDurationsLL`](/reference/lockup/contracts/contract.SablierBatchLockup#createwithdurationsll)
- [`createWithTimestampsLL`](/reference/lockup/contracts/contract.SablierBatchLockup#createwithtimestampsll)

Which one you choose depends upon your use case. In this guide, we will use `createWithDurationsLL`.

<BatchCommonSteps />

## Stream Parameters

Given that we declared a `batchSize` of two, we need to define two
[BatchLockup.CreateWithDurationsLL](/reference/lockup/contracts/types/library.BatchLockup#createwithdurationsll)
structs:

```solidity
// Declare the first stream in the batch
BatchLockup.CreateWithDurationsLL memory stream0;
stream0.sender = address(0xABCD); // The sender to stream the tokens, he will be able to cancel the stream
stream0.recipient = address(0xCAFE); // The recipient of the streamed tokens
stream0.totalAmount = perStreamAmount; // The total amount of each stream, inclusive of all fees
stream0.cancelable = true; // Whether the stream will be cancelable or not
stream0.transferable = false; // Whether the recipient can transfer the NFT or not
stream0.durations = LockupLinear.Durations({
    cliff: 4 weeks, // Assets will be unlocked only after 4 weeks
    total: 52 weeks // Setting a total duration of ~1 year
  });
stream0.unlockAmounts = LockupLinear.UnlockAmounts({
  start: 0, // Whether the stream will unlock a certain amount of tokens at the start time
  cliff: 0 // Whether the stream will unlock a certain amount of tokens at the cliff time
});
stream0.broker = Broker(address(0), ud60x18(0)); // Optional parameter left undefined
```

To add some variety, we will change the parameters of the second stream:

```solidity
// Declare the second stream in the batch
BatchLockup.CreateWithDurationsLL memory stream1;
stream1.sender = address(0xABCD); // The sender to stream the tokens, he will be able to cancel the stream
stream1.recipient = address(0xBEEF); // The recipient of the streamed tokens
stream1.totalAmount = perStreamAmount; // The total amount of each stream, inclusive of all fees
stream1.cancelable = false; // Whether the stream will be cancelable or not
stream1.transferable = false; // Whether the recipient can transfer the NFT or not
stream1.durations = LockupLinear.Durations({
    cliff: 1 weeks, // Assets will be unlocked only after 1 week
    total: 26 weeks // Setting a total duration of ~6 months
  });
stream1.unlockAmounts = LockupLinear.UnlockAmounts({
    start: 0, // Whether the stream will unlock a certain amount of tokens at the start time
    cliff: 0 // Whether the stream will unlock a certain amount of tokens at the start time
  });
stream1.broker = Broker(address(0), ud60x18(0)); // Optional parameter left undefined
```

Once both structs are declared, the batch array has to be filled:

```solidity
// Fill the batch param
BatchLockup.CreateWithDurationsLL[] memory batch = new BatchLockup.CreateWithDurationsLL[](batchSize);
batch[0] = stream0;
batch[1] = stream1;
```

## Invoke the batch create function

With all parameters set, we can now call the `createWithDurationsLL` function, and assign the ids of the newly created
streams to the array:

```solidity
streamIds = BATCH_LOCKUP.createWithDurationsLL(LOCKUP_LINEAR, DAI, batch);
```

## Full code

Below you can see the full code. You can also access the code on GitHub through
[this link](https://github.com/sablier-labs/examples/blob/main/lockup/BatchLLStreamCreator.sol).

```solidity reference title="Batch Lockup Linear stream creator"
https://github.com/sablier-labs/examples/blob/main/lockup/BatchLLStreamCreator.sol
```

================
File: docs/guides/lockup/examples/batch-create-streams/02-batch-lockup-dynamic.mdx
================
---
id: "batch-lockup-dynamic"
sidebar_position: 2
title: "Batch Lockup Dynamic"
---

import HardcodedDemonstration from "@site/src/components/atoms/HardcodedDemonstration";
import AdmonitionSimpleCode from "@site/src/snippets/AdmonitionSimpleCode.mdx";
import BatchCommonSteps from "@site/src/snippets/BatchCommonSteps.mdx";

# Create a Batch of Dynamic Streams

In this guide, we will show you how you can use Solidity to batch create dynamic streams via the
[Batch Lockup](/reference/lockup/contracts/contract.SablierBatchLockup) contract.

This guide assumes that you have already gone through the [Protocol Concepts](/concepts/streaming) section.

<AdmonitionSimpleCode />

## Set up a contract

Declare the Solidity version used to compile the contract:

```solidity
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity >=0.8.22;
```

Now, import the relevant symbols from `@sablier/lockup`:

```solidity
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ud2x18 } from "@prb/math/src/UD2x18.sol";
import { ud60x18 } from "@prb/math/src/UD60x18.sol";
import { ISablierBatchLockup } from "@sablier/lockup/src/interfaces/ISablierBatchLockup.sol";
import { ISablierLockup } from "@sablier/lockup/src/interfaces/ISablierLockup.sol";
import { BatchLockup, Broker, LockupDynamic } from "@sablier/lockup/src/types/DataTypes.sol";
```

Create a contract called `BatchLDStreamCreator`, and declare a constant `DAI` of type `IERC20`, a constant `LOCKUP` of
type `ISablierLockup`, and a constant `BATCH_LOCKUP` of type `ISablierBatchLockup`:

```solidity
contract BatchLDStreamCreator {
    IERC20 public constant DAI = IERC20(0x68194a729C2450ad26072b3D33ADaCbcef39D574);
    ISablierLockup public constant LOCKUP = ISablierLockup(0xC2Da366fD67423b500cDF4712BdB41d0995b0794);
    ISablierBatchLockup public constant BATCH_LOCKUP = ISablierBatchLockup(0xd4294579236eE290668c8FdaE9403c4F00D914f0);
}
```

<HardcodedDemonstration protocol="Lockup" />

## Batch create functions

There are two batch create functions for the Dynamic streams:

- [`createWithDurationsLD`](/reference/lockup/contracts/contract.SablierBatchLockup#createwithdurationsld)
- [`createWithTimestampsLD`](/reference/lockup/contracts/contract.SablierBatchLockup#createwithtimestampsld)

Which one you choose depends upon your use case. In this guide, we will use `createWithTimestampsLD`.

<BatchCommonSteps />

## Stream Parameters

Given that we declared a `batchSize` of two, we need to define two
[BatchLockup.CreateWithTimestampsLD](/reference/lockup/contracts/types/library.BatchLockup#createwithtimestampsld)
structs:

```solidity
// Declare the first stream in the batch
BatchLockup.CreateWithTimestampsLD memory stream0;
stream0.sender = address(0xABCD); // The sender to stream the tokens, he will be able to cancel the stream
stream0.recipient = address(0xCAFE); // The recipient of the streamed tokens
stream0.totalAmount = perStreamAmount; // The total amount of each stream, inclusive of all fees
stream0.cancelable = true; // Whether the stream will be cancelable or not
stream0.transferable = false; // Whether the recipient can transfer the NFT or not
stream0.startTime = uint40(block.timestamp); // Set the start time to block timestamp
// Declare some dummy segments
stream0.segments = new LockupDynamic.Segment[](2);
stream0.segments[0] = LockupDynamic.Segment({
    amount: uint128(perStreamAmount / 2),
    exponent: ud2x18(0.25e18),
    timestamp: uint40(block.timestamp + 1 weeks)
});
stream0.segments[1] = (
    LockupDynamic.Segment({
        amount: uint128(perStreamAmount - stream0.segments[0].amount),
        exponent: ud2x18(2.71e18),
        timestamp: uint40(block.timestamp + 24 weeks)
    })
);
stream0.broker = Broker(address(0), ud60x18(0)); // Optional parameter left undefined
```

To add some variety, we will change the parameters of the second stream:

```solidity
BatchLockup.CreateWithTimestampsLD memory stream1;
stream1.sender = address(0xABCD); // The sender to stream the tokens, he will be able to cancel the stream
stream1.recipient = address(0xBEEF); // The recipient of the streamed tokens
stream1.totalAmount = uint128(perStreamAmount); // The total amount of each stream, inclusive of all fees
stream1.cancelable = false; // Whether the stream will be cancelable or not
stream1.transferable = false; // Whether the recipient can transfer the NFT or not
stream1.startTime = uint40(block.timestamp); // Set the start time to block timestamp
// Declare some dummy segments
stream1.segments = new LockupDynamic.Segment[](2);
stream1.segments[0] = LockupDynamic.Segment({
    amount: uint128(perStreamAmount / 4),
    exponent: ud2x18(1e18),
    timestamp: uint40(block.timestamp + 4 weeks)
});
stream1.segments[1] = (
    LockupDynamic.Segment({
        amount: uint128(perStreamAmount - stream1.segments[0].amount),
        exponent: ud2x18(3.14e18),
        timestamp: uint40(block.timestamp + 52 weeks)
    })
);
stream1.broker = Broker(address(0), ud60x18(0)); // Optional parameter left undefined
```

Once both structs are declared, the batch array has to be filled:

```solidity
// Fill the batch array
BatchLockup.CreateWithTimestampsLD[] memory batch = new BatchLockup.CreateWithTimestampsLD[](batchSize);
batch[0] = stream0;
batch[1] = stream1;
```

## Invoke the batch create function

With all parameters set, we can now call the `createWithTimestampsLD` function, and assign the ids of the newly created
streams to the array:

```solidity
streamIds = BATCH_LOCKUP.createWithTimestampsLD(LOCKUP_DYNAMIC, DAI, batch);
```

## Full code

Below you can see the full code. You can also access the code on GitHub through
[this link](https://github.com/sablier-labs/examples/blob/main/lockup/BatchLDStreamCreator.sol).

```solidity reference title="Batch Lockup Dynamic stream creator"
https://github.com/sablier-labs/examples/blob/main/lockup/BatchLDStreamCreator.sol
```

================
File: docs/guides/lockup/examples/batch-create-streams/03-batch-lockup-tranched.mdx
================
---
id: "batch-lockup-tranched"
sidebar_position: 3
title: "Batch Lockup Tranched"
---

import HardcodedDemonstration from "@site/src/components/atoms/HardcodedDemonstration";
import AdmonitionSimpleCode from "@site/src/snippets/AdmonitionSimpleCode.mdx";
import BatchCommonSteps from "@site/src/snippets/BatchCommonSteps.mdx";

# Create a Batch of Tranched Streams

In this guide, we will show you how can use Solidity to batch create tranched streams via the
[Batch Lockup](/reference/lockup/contracts/contract.SablierBatchLockup) contract.

This guide assumes that you have already gone through the [Protocol Concepts](/concepts/streaming) section.

<AdmonitionSimpleCode />

## Set up a contract

Declare the Solidity version used to compile the contract:

```solidity
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity >=0.8.22;
```

Now, import the relevant symbols from `@sablier/lockup`:

```solidity
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ud60x18 } from "@prb/math/src/UD60x18.sol";
import { ISablierBatchLockup } from "@sablier/lockup/src/interfaces/ISablierBatchLockup.sol";
import { ISablierLockup } from "@sablier/lockup/src/interfaces/ISablierLockup.sol";
import { BatchLockup, Broker, LockupTranched } from "@sablier/lockup/src/types/DataTypes.sol";
```

Create a contract called `BatchLTStreamCreator`, and declare a constant `DAI` of type `IERC20`, a constant `LOCKUP` of
type `ISablierLockup`, and a constant `BATCH_LOCKUP` of type `ISablierBatchLockup`:

```solidity
contract BatchLTStreamCreator {
    IERC20 public constant DAI = IERC20(0x68194a729C2450ad26072b3D33ADaCbcef39D574);
    ISablierLockup public constant LOCKUP = ISablierLockup(0xC2Da366fD67423b500cDF4712BdB41d0995b0794);
    ISablierBatchLockup public constant BATCH_LOCKUP = ISablierBatchLockup(0xd4294579236eE290668c8FdaE9403c4F00D914f0);
}
```

<HardcodedDemonstration protocol="Lockup" />

## Batch create functions

There are two batch create functions for the Tranched streams:

- [`createWithDurationsLT`](/reference/lockup/contracts/contract.SablierBatchLockup#createwithdurationslt)
- [`createWithTimestampsLT`](/reference/lockup/contracts/contract.SablierBatchLockup#createwithtimestampslt)

Which one you choose depends upon your use case. In this guide, we will use `createWithTimestampsLT`.

<BatchCommonSteps />

## Stream Parameters

Given that we declared a `batchSize` of two, we need to define two
[BatchLockup.CreateWithTimestampsLT](/reference/lockup/contracts/types/library.BatchLockup#createwithtimestampslt)
structs:

```solidity
// Declare the first stream in the batch
BatchLockup.CreateWithTimestampsLT memory stream0;
stream0.sender = address(0xABCD); // The sender to stream the tokens, he will be able to cancel the stream
stream0.recipient = address(0xCAFE); // The recipient of the streamed tokens
stream0.totalAmount = perStreamAmount; // The total amount of each stream, inclusive of all fees
stream0.cancelable = true; // Whether the stream will be cancelable or not
stream0.transferable = false; // Whether the recipient can transfer the NFT or not
stream0.startTime = uint40(block.timestamp); // Set the start time to block timestamp
// Declare some dummy tranches
stream0.tranches = new LockupTranched.Tranche[](2);
stream0.tranches[0] = LockupTranched.Tranche({
    amount: uint128(perStreamAmount / 2),
    timestamp: uint40(block.timestamp + 1 weeks)
});
stream0.tranches[1] = LockupTranched.Tranche({
    amount: uint128(perStreamAmount - stream0.tranches[0].amount),
    timestamp: uint40(block.timestamp + 24 weeks)
});
stream0.broker = Broker(address(0), ud60x18(0)); // Optional parameter left undefined
```

To add some variety, we will change the parameters of the second stream:

```solidity
BatchLockup.CreateWithTimestampsLT memory stream1;
stream1.sender = address(0xABCD); // The sender to stream the tokens, he will be able to cancel the stream
stream1.recipient = address(0xBEEF); // The recipient of the streamed tokens
stream1.totalAmount = uint128(perStreamAmount); // The total amount of each stream, inclusive of all fees
stream1.cancelable = false; // Whether the stream will be cancelable or not
stream1.transferable = false; // Whether the recipient can transfer the NFT or not
stream1.startTime = uint40(block.timestamp); // Set the start time to block timestamp
// Declare some dummy tranches
stream1.tranches = new LockupTranched.Tranche[](2);
stream1.tranches[0] = LockupTranched.Tranche({
    amount: uint128(perStreamAmount / 4),
    timestamp: uint40(block.timestamp + 4 weeks)
});
stream1.tranches[1] = LockupTranched.Tranche({
    amount: uint128(perStreamAmount - stream1.tranches[0].amount),
    timestamp: uint40(block.timestamp + 24 weeks)
});
stream1.broker = Broker(address(0), ud60x18(0)); // Optional parameter left undefined
```

Once both structs are declared, the batch array has to be filled:

```solidity
// Fill the batch array
BatchLockup.CreateWithTimestampsLT[] memory batch = new BatchLockup.CreateWithTimestampsLT[](batchSize);
batch[0] = stream0;
batch[1] = stream1;
```

## Invoke the batch create function

With all parameters set, we can now call the `createWithTimestampsLT` function, and assign the ids of the newly created
streams to the array:

```solidity
streamIds = BATCH_LOCKUP.createWithTimestampsLT(LOCKUP_TRANCHED, DAI, batch);
```

## Full code

Below you can see the full code. You can also access the code on GitHub through
[this link](https://github.com/sablier-labs/examples/blob/main/lockup/BatchLTStreamCreator.sol).

```solidity reference title="Batch Lockup Tranched stream creator"
https://github.com/sablier-labs/examples/blob/main/lockup/BatchLTStreamCreator.sol
```

================
File: docs/guides/lockup/examples/create-stream/01-lockup-linear.mdx
================
---
id: "lockup-linear"
sidebar_position: 1
title: "Lockup Linear"
---

import HardcodedDemonstration from "@site/src/components/atoms/HardcodedDemonstration";
import AdmonitionSimpleCode from "@site/src/snippets/AdmonitionSimpleCode.mdx";
import LockupParam from "@site/src/snippets/LockupParams.mdx";
import TokenApproval from "@site/src/snippets/TokenApproval.mdx";

# Create a Lockup Linear Stream

Linear streams are streams with a linear streaming function. In this guide, we will show you how to create a Lockup
Linear stream using Solidity.

This guide assumes that you have already gone through the [Protocol Concepts](/concepts/streaming) section.

<AdmonitionSimpleCode />

## Set up a contract

Declare the Solidity version used to compile the contract:

```solidity
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity >=0.8.22;
```

Import the relevant symbols from `@sablier/lockup`:

```solidity
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ud60x18 } from "@prb/math/src/UD60x18.sol";
import { ISablierLockup } from "@sablier/lockup/src/interfaces/ISablierLockup.sol";
import { Broker, Lockup, LockupLinear } from "@sablier/lockup/src/types/DataTypes.sol";
```

Create a contract called `LockupLinearStreamCreator`, and declare a constant `DAI` of type `IERC20` and a constant
`LOCKUP` of type `ISablierLockup`:

```solidity
contract LockupLinearStreamCreator {
    IERC20 public constant DAI = IERC20(0x68194a729C2450ad26072b3D33ADaCbcef39D574);
    ISablierLockup public constant LOCKUP = ISablierLockup(0xC2Da366fD67423b500cDF4712BdB41d0995b0794);
}
```

<HardcodedDemonstration protocol="Lockup" />

There are two create functions in the Lockup contract that can be used to create Linear streams:

- `createWithDurationsLL`: takes duration and calculates the start and end timestamps based on the provided durations.
- `createWithTimestampsLL`: takes start and end timestamps.

Which one you choose depends upon your use case. In this guide, we will use `createWithDurationsLL`.

## Function definition

Define a function called `createStream` which takes a single parameter `totalAmount`, and which returns the id of the
created stream:

```solidity
function createStream(uint128 totalAmount) public returns (uint256 streamId) {
  // ...
}
```

<TokenApproval />

## Parameters

The struct associated with `createWithDurationsLL` are
[`Lockup.CreateWithDurations`](/reference/lockup/contracts/types/library.Lockup#createwithdurations) (a shared struct
across all the lockup streams),
[`LockupLinear.durations`](/reference/lockup/contracts/types/library.LockupLinear#durations) and
[`LockupLinear.unlockamounts`](/reference/lockup/contracts/types/library.LockupLinear#unlockamounts).

```solidity
Lockup.CreateWithDurations memory params;
LockupLinear.UnlockAmounts memory unlockAmounts;
LockupLinear.Durations memory durations;
```

Let's review each parameter in detail.

<LockupParam />

### Durations

Struct containing (i) cliff duration and (ii) total stream duration, both denoted in seconds.

```solidity
durations = LockupLinear.Durations({
    cliff: 0,
    total: 52 weeks
});
```

### Unlock Amounts

Struct containing details on unlock amounts at start time and at cliff time.

```solidity
unlockAmounts = LockupLinear.UnlockAmounts({ start: 0, cliff: 0 });
```

## Invoke the create function

With all parameters set, we can now call the `createWithDurationsLL` function, and assign the id of the newly created
stream to a variable:

```solidity
streamId = LOCKUP.createWithDurationsLL(params, unlockAmounts, durations);
```

## Full code

Below you can see the full code. You can also access the code on GitHub through
[this link](https://github.com/sablier-labs/examples/blob/main/lockup/LockupLinearStreamCreator.sol).

```solidity reference title="Lockup Linear Stream Creator"
https://github.com/sablier-labs/examples/blob/main/lockup/LockupLinearStreamCreator.sol
```

================
File: docs/guides/lockup/examples/create-stream/02-lockup-tranched.mdx
================
---
id: "lockup-tranched"
sidebar_position: 3
title: "Lockup Tranched"
---

import HardcodedDemonstration from "@site/src/components/atoms/HardcodedDemonstration";
import AdmonitionSimpleCode from "@site/src/snippets/AdmonitionSimpleCode.mdx";
import LockupParam from "@site/src/snippets/LockupParams.mdx";
import TokenApproval from "@site/src/snippets/TokenApproval.mdx";

# Create a Lockup Tranched Stream

Lockup Tranched are streams with discrete unlocks. In this guide, we will show you how to create a Lockup Tranched
stream using Solidity.

This guide assumes that you have already gone through the [Protocol Concepts](/concepts/streaming) section.

<AdmonitionSimpleCode />

## Set up a contract

Declare the Solidity version used to compile the contract:

```solidity
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity >=0.8.22;
```

Import the relevant symbols from `@sablier/lockup`:

```solidity
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ud60x18 } from "@prb/math/src/UD60x18.sol";
import { ISablierLockup } from "@sablier/lockup/src/interfaces/ISablierLockup.sol";
import { Broker, Lockup, LockupTranched } from "@sablier/lockup/src/types/DataTypes.sol";
```

Create a contract called `LockupTranchedStreamCreator`, and declare a constant `DAI` of type `IERC20` and a constant
`LOCKUP` of type `ISablierLockup`:

```solidity
contract LockupTranchedStreamCreator {
    IERC20 public constant DAI = IERC20(0x68194a729C2450ad26072b3D33ADaCbcef39D574);
    ISablierLockup public constant LOCKUP = ISablierLockup(0xC2Da366fD67423b500cDF4712BdB41d0995b0794);
}
```

<HardcodedDemonstration protocol="Lockup" />

There are two create functions in the Lockup contract that can be used to create Tranched streams:

- `createWithDurationsLT`: takes duration and calculates the tranche timestamps based on the provided durations.
- `createWithTimestampsLT`: takes UNIX timestamps for tranches.

Which one you choose depends upon your use case. In this guide, we will use `createWithDurationsLT`.

## Function definition

Define a function called `createStream` which takes two parameters, `amount0` and `amount1`, and which returns the id of
the created stream:

```solidity
function createStream(uint128 amount0, uint128 amount1) public returns (uint256 streamId) {
  // ...
}
```

Next, sum up the `amount0` and `amount1` parameters to get the total amount of the stream, which will be needed in many
of the steps below:

```solidity
uint256 totalAmount = amount0 + amount1;
```

<TokenApproval />

## Parameters

The struct associated with `createWithDurationsLT` are
[`Lockup.CreateWithDurations`](/reference/lockup/contracts/types/library.Lockup#createwithdurations) (a shared struct
across all the lockup streams) and
[`LockupTranched.TrancheWithDuration`](/reference/lockup/contracts/types/library.LockupTranched#tranchewithduration).

```solidity
Lockup.CreateWithDurations memory params;
LockupTranched.TrancheWithDuration[] memory tranches = new LockupTranched.TrancheWithDuration[](2);
```

Let's review each parameter in detail.

<LockupParam />

### Tranches With Duration

Tranches are what the protocol uses to compose the discrete unlocks. For a full exposition of tranches, see the
[Tranches](/concepts/lockup/tranches) guide.

Each tranche is characterized by a specific amount and timestamp. Because we are using `createWithDurationsLT` in this
example, these tranches are supplied to the function in the form of an array containing
[`LockupTranched.TrancheWithDuration`](/reference/lockup/contracts/types/library.LockupTranched#tranchewithduration)
structs.

Let's define two dummy tranches:

```solidity
params.tranches[0] = LockupTranched.TrancheWithDuration({
    amount: amount0,
    duration: uint40(4 weeks)
});
params.tranches[1] = (
    LockupTranched.TrancheWithDuration({
        amount: amount1,
        duration: uint40(6 weeks)
    })
);
```

In this example, the first tranche (`amount0`) will unlock at the end of the 4 weeks after the stream was created and
the second tranche (`amount1`) will unlock after further 6 weeks. Thus, the total amount will be unlocked in 10 weeks.

## Invoke the create function

With all parameters set, we can now call the `createWithDurationsLT` function, and assign the ID of the newly created
stream to a variable:

```solidity
streamId = LOCKUP.createWithDurationsLT(params, tranches);
```

## Full code

Below you can see the full code. You can also access the code on GitHub through
[this link](https://github.com/sablier-labs/examples/blob/main/lockup/LockupTranchedStreamCreator.sol).

```solidity reference title="Lockup Tranched Stream Creator"
https://github.com/sablier-labs/examples/blob/main/lockup/LockupTranchedStreamCreator.sol
```

================
File: docs/guides/lockup/examples/create-stream/03-lockup-dynamic.mdx
================
---
id: "lockup-dynamic"
sidebar_position: 3
title: "Lockup Dynamic"
---

import HardcodedDemonstration from "@site/src/components/atoms/HardcodedDemonstration";
import AdmonitionSimpleCode from "@site/src/snippets/AdmonitionSimpleCode.mdx";
import LockupParam from "@site/src/snippets/LockupParams.mdx";
import TokenApproval from "@site/src/snippets/TokenApproval.mdx";

# Create a Lockup Dynamic Stream

Dynamic streams are streams with a custom streaming function. In this guide, we will show you how to create a Lockup
Dynamic stream using Solidity.

This guide assumes that you have already gone through the [Protocol Concepts](/concepts/streaming) section.

<AdmonitionSimpleCode />

## Set up a contract

Declare the Solidity version used to compile the contract:

```solidity
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity >=0.8.22;
```

Import the relevant symbols from `@sablier/lockup`:

```solidity
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { ud2x18 } from "@prb/math/src/UD2x18.sol";
import { ud60x18 } from "@prb/math/src/UD60x18.sol";
import { ISablierLockup } from "@sablier/lockup/src/interfaces/ISablierLockup.sol";
import { Broker, Lockup, LockupDynamic } from "@sablier/lockup/src/types/DataTypes.sol";
```

Create a contract called `LockupDynamicStreamCreator`, and declare a constant `DAI` of type `IERC20` and a constant
`LOCKUP` of type `ISablierLockup`:

```solidity
contract LockupDynamicStreamCreator {
    IERC20 public constant DAI = IERC20(0x68194a729C2450ad26072b3D33ADaCbcef39D574);
    ISablierLockup public constant LOCKUP = ISablierLockup(0xC2Da366fD67423b500cDF4712BdB41d0995b0794);
}
```

<HardcodedDemonstration protocol="Lockup" />

There are two create functions in the Lockup contract that can be used to create Dynamic streams:

- `createWithDurationsLD`: takes duration and calculates the segment timestamps based on the provided durations.
- `createWithTimestampsLD`: takes UNIX timestamps for segment.

Which one you choose depends upon your use case. In this guide, we will use `createWithTimestampsLD`.

## Function definition

Define a function called `createStream` which takes two parameters, `amount0` and `amount1`, and which returns the id of
the created stream:

```solidity
function createStream(uint128 amount0, uint128 amount1) public returns (uint256 streamId) {
  // ...
}
```

Next, sum up the `amount0` and `amount1` parameters to get the total amount of the stream, which will be needed in many
of the steps below:

```solidity
uint256 totalAmount = amount0 + amount1;
```

<TokenApproval />

## Parameters

The struct associated with `createWithTimestampsLD` are
[`Lockup.CreateWithTimestamps`](/reference/lockup/contracts/types/library.Lockup#createwithtimestamps) (a shared struct
across all the lockup streams) and
[`LockupDynamic.Segment`](/reference/lockup/contracts/types/library.LockupDynamic#segment).

```solidity
LockupDynamic.CreateWithTimestamps memory params;
LockupDynamic.Segment[] memory segments = new LockupDynamic.Segment[](2);
```

Let's review each parameter in detail.

<LockupParam />

### Start Time and End Time

The start and end timestamps for the stream. Note that the end timestamps much match the timestamp of the last segment.

```solidity
params.timestamps.start = uint40(block.timestamp + 100 seconds);
params.timestamps.end = uint40(block.timestamp + 52 weeks);
```

### Segments

Segments are what the protocol uses to compose the custom distribution curve of a Dynamic stream. For a full exposition
of segments, see the [Segments](/concepts/lockup/segments) guide.

The term "segment" refers to the splitting of the stream into separate partitions, with each segment characterized by a
specific amount, exponent, and timestamp. These segments are supplied to the function in the form of an array containing
[`LockupDynamic.Segment`](/reference/lockup/contracts/types/library.LockupDynamic#segment) structs.

Let's define two dummy segments:

```solidity
segments[0] = LockupDynamic.Segment({
    amount: amount0,
    exponent: ud2x18(1e18),
    timestamp: uint40(block.timestamp + 4 weeks)
});
segments[1] = (
    LockupDynamic.Segment({
        amount: amount1,
        exponent: ud2x18(3.14e18),
        timestamp: uint40(block.timestamp + 52 weeks)
    })
);
```

In this example, the first segment (`amount0`) will stream much faster than the second segment (`amount1`), because the
exponents are different. As a rule of thumb: the higher the exponent, the slower the stream.

:::note

The segment timestamp must be in ascending order.

:::

:::info

The `ud2x18` function wraps a basic integer to the `UD2x18` value type, which is part of the
[PRBMath](https://github.com/PaulRBerg/prb-math) library.

:::

## Invoke the create function

With all parameters set, we can now call the `createWithTimestampsLD` function, and assign the id of the newly created
stream to a variable:

```solidity
streamId = LOCKUP.createWithTimestampsLD(params, segments);
```

## Full code

Below you can see the full code. You can also access the code on GitHub through
[this link](https://github.com/sablier-labs/examples/blob/main/lockup/LockupDynamicStreamCreator.sol).

```solidity reference title="Lockup Dynamic Stream Creator"
https://github.com/sablier-labs/examples/blob/main/lockup/LockupDynamicStreamCreator.sol
```

================
File: docs/apps/guides/02-url-schemes.mdx
================
---
id: "url-schemes"
sidebar_position: 2
title: "URL Schemes"
---

The Sablier Interface makes it easy for integrators to direct their users to specific resources. In this guide, we will
cover a number of resource locators used by the apps, as well as dive into how you can understand and re-create them.

## Stream Page

|                                                   |
| ------------------------------------------------- |
| ![Stream profile](/screenshots/stream-share.webp) |

### Elements

Every stream created through the Sablier Protocol is identified through three parameters:

- a **chainId** (e.g., `1` for Ethereum, `10` for [OP Mainnet](https://chainlist.org/) )
- an **alias** (e.g., `LK`) OR a **contract** (e.g. `0x12..AB`)
- a **streamId** (generated at stream creation)

#### Contract Aliases

Sablier supports different token distribution products, e.g. `SablierLockup` and `SablierFlow`. To provide a visual
resolver in the UI, we alias the contract addresses with the following abbreviations:

In the past, the functionality of the `SablierLockup` contract used to be distributed among different contracts.

- Lockup Linear V2.0 contracts become `LL`, e.g. `LL-137-1`
- Lockup Linear V2.1 contracts become `LL2`, e.g. `LL2-137-1`
- Lockup Dynamic V2.0 contracts become `LD`, e.g. `LD-137-1`
- Lockup Dynamic V2.1 contracts become `LD2`, e.g. `LD2-137-1`

### Building the URL

By combining the elements described above, you can send users from your interface directly to the create stream page in
the Sablier Interface. To build the link to a stream resource, you use a hyphen `-` to concatenate the uppercase
contract `alias`, the `chainId`, and the `streamId`, and then you add them to the base URL `app.sablier.com/stream/`:

| URL                                                                                                                     | Description                                       |
| :---------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------ |
| [app.sablier.com/stream/LL2-137-29](https://app.sablier.com/stream/LL2-137-29)                                          | Lockup Linear V2.1 stream #29 on Polygon          |
| [app.sablier.com/stream/LL-137-32](https://app.sablier.com/stream/LL-137-32)                                            | Lockup Linear V2.0 stream #32 on Polygon          |
| [app.sablier.com/stream/LD-137-13](https://app.sablier.com/stream/LD-137-13)                                            | Lockup Dynamic V2.0 stream #13 on Polygon         |
| [app.sablier.com/stream/LL-1-6](https://app.sablier.com/stream/LL-1-6)                                                  | Lockup Linear V2.0 stream #6 on Ethereum          |
| [app.sablier.com/stream/0xB10...f95-1-6](https://app.sablier.com/stream/0xB10daee1FCF62243aE27776D7a92D39dC8740f95-1-6) | Lockup Linear V2.0 stream #6 on Ethereum          |
| [app.sablier.com/stream/LL2-11155111-40](https://app.sablier.com/stream/LL2-11155111-40)                                | Lockup Linear V2.1 stream #40 on Ethereum Sepolia |

As you can see, the main format is `contractA-chainId-streamId`. This is supported both at the app and the subgraph
level. For situations when an alias cannot be used, we fallback to the following format:
`contractAddress-chainId-streamId`. Read more about identifiers and aliases in our
[subgraph documentation](/api/lockup/the-graph/structure#identifying).

---

## Search Streams

### Elements

The Sablier Interface comes with an advanced search view that can be accessed directly through URL parameters. If you
want to use this feature, here is a table with all the available parameters:

| Parameter | Type         | Description                                                                | Values                                                                    |
| :-------- | :----------- | :------------------------------------------------------------------------- | ------------------------------------------------------------------------- |
| t         | String       | The active tab in the dashboard. For global queries, use `search`.         | `search`, `sender`, or `recipient`                                        |
| c         | Number       | The chain of the streams in the search result. This parameter is required. | `1`, `10`, `42161` or other [supported chain](/guides/lockup/deployments) |
| s         | String       | The address of the stream sender by which to filter                        | `0x12...AB`, `vitalik.eth`                                                |
| r         | String       | The address of the stream recipient by which to filter                     | `0x12...AB`, `vitalik.eth`                                                |
| a         | String       | The address of the asset to filter for                                     | `0x12...CD` for DAI                                                       |
| i         | String array | An array of IDs to look up                                                 | `LL-5-1`, `LD-5-14` etc.                                                  |

### Building the URL

By combining the parameters described above, you can send users from your interface directly to the search view in the
Sablier Interface. To build the link, you append all these elements to the base link `app.sablier.com/` as query
parameters, e.g. `?t=search&c=1&s=0x..1&r=0x...2&i=LL-1-2,LL2-1-29`.

Here are some examples of URLs and the associated search modal for each:

|                                                                                                                            |                                               |
| -------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------- |
| [Streams created by a particular user](https://app.sablier.com/?t=search&c=1&s=0x0aAeF7BbC21c627f14caD904E283e199cA2b72cC) | ![Form](/screenshots/search-with-sender.webp) |
| [Streams with particular IDs](https://app.sablier.com/?t=search&c=1&i=LL2-1-2,LL-1-29)                                     | ![Form](/screenshots/search-with-ids.webp)    |

---

## Airdrop Page

|                                                       |
| ----------------------------------------------------- |
| ![Airdrop Profile](/screenshots/airdrop-profile.webp) |

### Elements

Every airdrop created through the Lockup protocol is identified through three parameters:

- a **chainId** (e.g. `1` for Ethereum, `10` for [Optimism](https://chainlist.org/) )
- a **contract** address (e.g. `0x12..AB`)

:::info

We've chosen not to apply aliases to Airstreams for now. In the future, we may ask the campaign creator to provide a
name or an alias to be used in the URL.

:::

### Building the URL

By combining the elements described above, you can send users from your interface directly to the create stream page in
the Sablier Interface. To build the link to a stream resource, you use a hyphen `-` to concatenate the uppercase
contract `alias`, the `chainId`, and the `streamId`, and then you add them to the base URL `app.sablier.com/stream/`:

| URL                                                                                                                                       | Description                   |
| :---------------------------------------------------------------------------------------------------------------------------------------- | :---------------------------- |
| [app.sablier.com/stream/0xe72[...]bbabc-11155111](https://app.sablier.com/airstream/0xe72175dd12ac7efca6b7d12dfc913a5f661bbabc-11155111/) | Airstream on Ethereum Sepolia |

As you can see, the main format is `contractA-chainId`. This is supported both at the app and the subgraph level. Read
more about identifiers and aliases in our [subgraph documentation](/api/airdrops/the-graph/entities#identifying).

## Search Airstreams

### Elements

The Sablier Interface comes with an advanced search view that can be accessed directly through URL parameters. If you
want to use this feature, here is a table with all the available parameters:

| Parameter | Type   | Description                                                                   | Values                                                                    |
| :-------- | :----- | :---------------------------------------------------------------------------- | ------------------------------------------------------------------------- |
| t         | String | The active tab in the dashboard. For global queries, use `search`.            | `search`                                                                  |
| c         | Number | The chain of the airstreams in the search result. This parameter is required. | `1`, `10`, `42161` or other [supported chain](/guides/lockup/deployments) |
| m         | String | The address of the campaign admin by which to filter                          | `0x12...AB`, `vitalik.eth`                                                |
| a         | String | The address of the asset to filter for                                        | `0x12...CD` for DAI                                                       |

### Building the URL

By combining the parameters described above, you can send users from your interface directly to the search view in the
Sablier Interface. To build the link, you append all these elements to the base link `app.sablier.com/airdrops` as query
parameters, e.g. `?t=search&c=1&m=0x..1&a=0x`.

================
File: docs/concepts/01-what-is-sablier.mdx
================
---
id: "what-is-sablier"
sidebar_position: 1
title: "What Is Sablier?"
---

import Link from "@docusaurus/Link";
import ReleaseHistoryAirdrops from "@site/src/snippets/ReleaseHistoryAirdrops.mdx";
import ReleaseHistoryFlow from "@site/src/snippets/ReleaseHistoryFlow.mdx";
import ReleaseHistoryLegacy from "@site/src/snippets/ReleaseHistoryLegacy.mdx";
import ReleaseHistoryLockup from "@site/src/snippets/ReleaseHistoryLockup.mdx";

Sablier is a powerful onchain token distribution protocol. Here are some key definitions:

- **The Sablier Protocol**: A collection of persistent, non-upgradeable smart contracts to facilitate streaming of
  ERC-20 tokens on Ethereum and other EVM blockchains. The Sablier Protocol consists of Lockup, Merkle Airdrops, and
  Flow.
- **The Sablier Interface**: A web interface that allows for easy interaction with the Sablier Protocol. The interface
  is only one of many ways to interact with the Sablier Protocol.
- **Sablier Labs**: The company that develops the Sablier Protocol, the Sablier Interface, and the documentation website
  you are reading right now.

:::info

Fun fact: "sablier" means "hourglass" in French.

:::

## Sablier Protocol

A software protocol built with [Ethereum](https://ethereum.org/) smart contracts, designed to facilitate distribution of
[ERC-20](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/) tokens. The protocol employs a set of
persistent and non-upgradable smart contracts that prioritize security, censorship resistance, self-custody, and
functionality without the need for trusted intermediaries who may selectively restrict access.

Currently, Sablier consists of three separate systems:

- **Lockup**: facilitates vesting and vested airdrops
- **Merkle Airdrops**: enables on-chain airdrops
- **Flow**: for payroll, grants etc.

While most of these are licensed under BUSL-1.1, there are some components licensed under GPL v3. The source code can be
accessed on Sablier's [GitHub account](https://github.com/sablier-labs), and a detailed technical reference can be found
in the [Technical References](/reference/overview) section of this website.

As long as Ethereum and the other EVM chains continue to exist, every version of the Sablier Protocol that gets deployed
will operate continuously and without interruption, with a guarantee of 100% uptime.

:::info

Sablier is the first project to enable token streaming in the Ethereum ecosystem, tracing its roots
[back to 2019](https://x.com/Sablier/status/1205533344886411264).

:::

## How does Sablier differ from traditional payment systems?

To understand the unique characteristics of Sablier, it is helpful to examine two aspects: the permissionless nature of
the protocol compared to traditional payment systems, the concept of streaming as an alternative to conventional payment
methods.

### Permissionless systems

Sablier is rooted in the essential ideas of open access and immutability, deriving inspiration from Ethereum's
foundational principles and the core values of the DeFi[^1] movement. These concepts are crucial in shaping a future
where financial services are accessible to everyone, irrespective of their geographical location or economic standing,
without prejudice or exposure to counterparty risks.

The permissionless design ensures that the protocol's services are open to the public, without any restrictions on who
can use them. Users have the liberty to establish new streams with any ERC-20 token, or interact with existing streams
as they wish. This feature stands in sharp contrast to conventional financial services that frequently impose
restrictions based on factors such as location, financial status, or age.

As an immutable system, the Sablier Protocol is non-upgradeable, meaning that no party can pause the contracts, reverse
transactions, or alter the users' streams in any way. This ensures the system remains transparent, secure, and resistant
to manipulation or abuse.

### Streaming vs conventional payments

Traditional payment systems generally involve lump-sum transfers, which rely on trust between parties, have slow
processing times, and are prone to errors. In the context of bank transfers, payments are also subject to substantial
fees and can face delays due to intermediaries.

By contrast, Sablier introduces the concept of token streaming, enabling users to make continuous, real-time payments on
a per-second basis. This innovative approach enables seamless, frictionless transactions and promotes increased
financial flexibility for users, businesses, and other entities. Sablier makes the passage of time itself the
trust-binding mechanism, unlocking business opportunities that were previously unavailable.

A good mental model to contrast streaming with conventional payment models is to view the former as "real-time finance"
or "continuous finance", and the latter as of "discrete finance".

## Where can I find more information?

For more details on the Sablier Protocol, its features, and potential use cases, explore this documentation site and
visit the official [Sablier website](https://sablier.com) as well.

:::tip

If you have any questions along the way, please join the #dev channel in our <Link
href={"https://discord.sablier.com"}>Discord server</Link>. Our team and members of the community are looking forward to
help you.

:::

## Release history

### Lockup

For more details on the UI alias, see the guide on [URL schemes](/apps/guides/url-schemes).

<ReleaseHistoryLockup />

### Merkle Airdrops

<ReleaseHistoryAirdrops />

Before v1.3, Merkle Airdrops contracts were part of the Sablier Lockup
[periphery repository](https://github.com/sablier-labs/v2-periphery).

### Flow

For more details on the UI alias, see the guide on [URL schemes](/apps/guides/url-schemes).

<ReleaseHistoryFlow />

### Legacy (Deprecated)

The Legacy contracts have been superseded by Lockup.

<ReleaseHistoryLegacy />

[^1]:
    Short for Decentralized Finance: an ecosystem of financial applications and services built on blockchain networks,
    primarily Ethereum, that leverage smart contracts to enable trustless, permissionless, and transparent financial
    transactions without relying on traditional intermediaries like banks or financial institutions.

================
File: docs/guides/airdrops/02-airdrops-deployments.mdx
================
C---
id: "deployments"
sidebar_position: 2
title: "Deployment Addresses"

---

import DeploymentsV1_3 from "@site/src/autogen/airdrops/TableDeploymentsV1.3.mdx";

# Merkle Airdrops Deployments

This section contains the deployment addresses for the v1.3 release of
[@sablier/airdrops](https://npmjs.com/package/@sablier/airdrops).

A few noteworthy details about the deployments:

- The addresses are final
- All contracts are non-upgradeable
- The source code is verified on Etherscan across all chains

## Previous Versions

This repository is the successor of [Lockup Periphery](https://github.com/sablier-labs/v2-periphery), which has been
discontinued. For previous deployments, please refer to the
[Lockup deployments](/guides/lockup/previous-deployments/v1.2) page.

<DeploymentsV1_3 />

================
File: docs/guides/flow/examples/04-stream-management.mdx
================
---
id: "stream-management"
sidebar_position: 4
title: "Stream Management"
---

import HardcodedDemonstration from "@site/src/components/atoms/HardcodedDemonstration";
import AdmonitionSimpleCode from "@site/src/snippets/AdmonitionSimpleCode.mdx";

# Managing a Stream

This section will guide you through the different functions of Flow and how to interact with them. Before diving in,
please note the following:

1. We assume you are already familiar with [creating Flow streams](./03-create-stream.mdx).
2. We also assume that the stream management contract is authorized to invoke each respective function. To learn more
   about access control in Flow, see the [Access Control](/reference/flow/access-control) guide.

<AdmonitionSimpleCode />

# Set up your contract

Declare the Solidity version used to compile the contract:

```solidity
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity >=0.8.22;
```

Import the relevant symbols from `@sablier/flow` and `@prb/math`:

```solidity
import { ud21x18 } from "@prb/math/src/UD21x18.sol";
import { ud60x18 } from "@prb/math/src/UD60x18.sol";
import { Broker, ISablierFlow } from "@sablier/flow/src/interfaces/ISablierFlow.sol";
```

Declare the contract and add the Flow address as a constant:

```solidity
contract FlowStreamManager {
    ISablierFlow public constant FLOW = ISablierFlow(0x52ab22e769E31564E17D524b683264B65662A014);
}
```

<HardcodedDemonstration protocol="Flow" />

## Deposit

Depositing into streams means adding tokens to the stream, which will then be distributed to the recipient based on the
value of rate per second.

:::info

A deposit is also referred to as a top-up.

:::

There are three deposit functions:

1. [`deposit`](/reference/flow/contracts/contract.SablierFlow#deposit): deposits an amount of tokens.
2. [`depositAndPause`](/reference/flow/contracts/contract.SablierFlow#depositandpause): deposits an amount of tokens and
   then pauses the stream.
3. [`depositViaBroker`](/reference/flow/contracts/contract.SablierFlow#depositviabroker): deposits an amount of tokens
   and transfers a fee to the [broker](/concepts/glossary#broker-fee) specified.

```solidity
function deposit(uint256 streamId, uint256 amount) external {
    FLOW.deposit(streamId, amount);
}

function depositAndPause(uint256 streamId) external {
    FLOW.depositAndPause(streamId, 3.14159e18);
}

function depositViaBroker(uint256 streamId) external {
    Broker memory broker = Broker({ account: address(0xDEAD), fee: ud60x18(0.0001e18) });

    FLOW.depositViaBroker({
        streamId: streamId,
        totalAmount: 3.14159e18,
        sender: msg.sender,
        recipient: address(0xCAFE),
        broker: broker
    });
}
```

## Withdraw

The recipient of a stream can withdraw any amount, not exceeding the withdrawable amount. The recipient also has the
option to withdraw the tokens to an alternate address of their choice.

There are two withdrawal functions:

1. [`withdraw`](/reference/flow/contracts/contract.SablierFlow#withdraw): withdraws an amount of tokens not exceeding
   the withdrawable amount.
2. [`withdrawMax`](/reference/flow/contracts/contract.SablierFlow#withdrawmax): withdraws the entire withdrawable amount
   of tokens.

```solidity
function withdraw(uint256 streamId) external {
    FLOW.withdraw({ streamId: streamId, to: address(0xCAFE), amount: 2.71828e18 });
}

function withdrawMax(uint256 streamId) external {
    FLOW.withdrawMax({ streamId: streamId, to: address(0xCAFE) });
}
```

## Adjust Rate per Second

Adjusting the rate per second means changing the amount of tokens that is streamed each second.

```solidity
function adjustRatePerSecond(uint256 streamId) external {
    FLOW.adjustRatePerSecond({ streamId: streamId, newRatePerSecond: ud21x18(0.0001e18) });
}
```

## Pause

Pausing a stream means setting the rate per second to zero, which means no more streaming.

```solidity
function pause(uint256 streamId) external {
    FLOW.pause(streamId);
}
```

## Restart

There are two restart functions:

1. [`restart`](/reference/flow/contracts/contract.SablierFlow#restart): restarts a stream.
2. [`restartAndDeposit`](/reference/flow/contracts/contract.SablierFlow#restartanddeposit): restarts a stream followed
   by depositing an amount of tokens into it.

```solidity
function restart(uint256 streamId) external {
    FLOW.restart({ streamId: streamId, ratePerSecond: ud21x18(0.0001e18) });
}

function restartAndDeposit(uint256 streamId) external {
    FLOW.restartAndDeposit({ streamId: streamId, ratePerSecond: ud21x18(0.0001e18), amount: 2.71828e18 });
}
```

## Refund

There are three refund functions:

1. [`refund`](/reference/flow/contracts/contract.SablierFlow#refund): refunds an amount of tokens not exceeding the
   refundable amount.
2. [`refundAndPause`](/reference/flow/contracts/contract.SablierFlow#refundandpause): refunds an amount of tokens, and
   then pauses the stream.
3. [`refundMax`](/reference/flow/contracts/contract.SablierFlow#refundmax): refunds the entire refundable amount of
   tokens.

```solidity
function refund(uint256 streamId) external {
    FLOW.refund({ streamId: streamId, amount: 1.61803e18 });
}

function refundAndPause(uint256 streamId) external {
    FLOW.refundAndPause({ streamId: streamId, amount: 1.61803e18 });
}

function refundMax(uint256 streamId) external {
    FLOW.refundMax(streamId);
}
```

## Void

Voiding a stream means permanently stopping it from streaming any tokens. This is slightly different from pausing a
stream because it also sets the stream's uncovered debt to zero.

```solidity
function void(uint256 streamId) external {
    FLOW.void(streamId);
}
```

## Full code

Below you can see the complete `FlowStreamManager` contract:

```solidity reference title="Flow Stream Manager"
https://github.com/sablier-labs/examples/blob/main/flow/FlowStreamManager.sol
```

================
File: docs/guides/flow/02-flow-deployments.mdx
================
---
id: "deployments"
sidebar_position: 2
title: "Deployment Addresses"
---

import DeploymentsV1_1 from "@site/src/autogen/flow/TableDeploymentsV1.1.mdx";
import ReleaseHistoryFlow from "@site/src/snippets/ReleaseHistoryFlow.mdx";

# Flow Deployments

This section contains the deployment addresses for the v1.1 release of
[@sablier/flow](https://npmjs.com/package/@sablier/flow).

A few noteworthy details about the deployments:

- The addresses are final
- All contracts are non-upgradeable
- The source code is verified on Etherscan across all chains

## Versions

Any updates or additional features will require a new deployment of the protocol, due to its immutable nature.

Came here looking for the previous deployments? Click below to see other versions as well as the in-app aliases assigned
under our [naming convention](/api/flow/the-graph/structure#identifying).

<ReleaseHistoryFlow />

:::info

Stay up to date with any new releases by [subscribing](https://x.com/Sablier/status/1821220784661995627) to the official
Sablier repositories on Github.

:::

<DeploymentsV1_1 />

================
File: docs/guides/lockup/02-lockup-deployments.mdx
================
---
id: "deployments"
sidebar_position: 2
title: "Deployment Addresses"
---

import DeploymentsV2_0 from "@site/src/autogen/lockup/TableDeploymentsV2.0.mdx";
import ReleaseHistoryLockup from "@site/src/snippets/ReleaseHistoryLockup.mdx";

# Lockup Deployments

This section contains the deployment addresses for the v2.0 release of
[@sablier/lockup](https://npmjs.com/package/@sablier/lockup).

A few noteworthy details about the deployments:

- The addresses are final
- All contracts are non-upgradeable
- The source code is verified on Etherscan across all chains

:::info[important]

Lockup Periphery repo has been discontinued in favor of the new [Merkle Airdrops repo](/guides/airdrops/overview).

:::

## Versions

Any updates or additional features will require a new deployment of the protocol, due to its immutable nature.

Came here looking for the previous Lockup deployments? Click below to see other versions as well as the in-app aliases
assigned under our [naming convention](/api/lockup/the-graph/structure#identifying).

<ReleaseHistoryLockup />

Or maybe you're looking for Legacy? [Click here](/guides/legacy/deployments).

:::info

Stay up to date with any new releases by [subscribing](https://x.com/Sablier/status/1821220784661995627) to the official
Sablier repositories on Github.

:::

<DeploymentsV2_0 />

================
File: docs/apps/guides/01-csv-support.mdx
================
---
id: "csv-support"
sidebar_position: 1
title: "CSV Support"
---

import LinkPreview from "@site/src/components/molecules/LinkPreview";

The Sablier Interfaces supports CSV files for faster processing and automating large-scale operations. This feature is
available for both airdrops and streams.

:::warning Formatting Caveats

**Dates**: All columns with the "date" type should have the following format: "YYYY-MM-DD HH:mm".

**Durations**: All columns with the "duration" type should have the following format: "**x** years **y** days **z**
hours". Note that each particle is optional, e.g., you can skip the days.

**Timezones**: The dates and times extracted from the CSV are processed using the same timezone used by the user's
browser.

**Amounts**: All token amounts should be expressed in humanized form, e.g., 10 USDC should be written as `10`, not
`10000000`. The Sablier app will multiply the amounts by the token's number of decimals in the processing step.

:::

## Airdrops

With Sablier, you can create airdrop campaigns with up to a million recipients. To do so, you must upload a CSV file
containing all recipient addresses and the airdrop amounts.

Use the provided template and fill in the rows with recipient addresses and airdrop amounts.

### CSV Template

For your convenience, here's a download link for the CSV template:

<LinkPreview
  href="https://files.sablier.com/templates/airdrop-template.csv"
  icon="sablier"
  subtitle="CSV template for creating airdrops on Sablier"
  title="Sablier - Airdrop CSV Template"
/>

### Navigation

To use this feature:

1. Access the [create airdrop](https://app.sablier.com/airdrops/create) page
2. Fill out the details for your airdrop campaign in the 1st step
3. Continue to the 2nd step, where you can upload the CSV

|                                                       |
| ----------------------------------------------------- |
| ![Airdrop Create](/screenshots/airdrop-create-2.webp) |

## Streams

|                                                       |
| ----------------------------------------------------- |
| ![Create with CSV](/screenshots/create-with-csv.webp) |

Using a CSV, you can deploy up to 280 streams all at once. Start from the suggested template, and fill in the rows with
addresses, amounts, and other details.

### CSV Template

Here's table with all the available CSV templates:

| URL                                                                                                           | Description                                         |
| :------------------------------------------------------------------------------------------------------------ | :-------------------------------------------------- |
| [Flow](https://files.sablier.com/templates/flow-template.csv)                                                 | Open-ended streams that can be topped up.           |
| [Linear with duration](https://files.sablier.com/templates/linear-duration-template.csv)                      | Linear streams with the duration timing.            |
| [Linear with range](https://files.sablier.com/templates/linear-range-template.csv)                            | Linear streams with the range timing.               |
| [Cliff with duration](https://files.sablier.com/templates/2025-02/cliff-duration-template.csv)                | Cliff streams with the duration timing.             |
| [Cliff with range](https://files.sablier.com/templates/2025-02/cliff-range-template.csv)                      | Cliff streams with the range timing.                |
| [Monthly with range](https://files.sablier.com/templates/monthly-range-template.csv)                          | Unlock Each Month streams with the range timing.    |
| [Stepper with duration](https://files.sablier.com/templates/2025-02/unlockSteps-duration-template.csv)        | Unlock In Steps streams with the duration timing.   |
| [Stepper with range](https://files.sablier.com/templates/2025-02/unlockSteps-range-template.csv)              | Unlock In Steps streams with the duration timing.   |
| [Timelock with duration](https://files.sablier.com/templates/timelock-duration-template.csv)                  | Timelock streams with the duration timing.          |
| [Timelock with range](https://files.sablier.com/templates/timelock-range-template.csv)                        | Timelock streams with the range timing.             |
| [BackWeighted with range](https://files.sablier.com/templates/backWeighted-range-template.csv)                | BackWeighted streams with the range timing.         |
| [Unlock linear with duration](https://files.sablier.com/templates/unlockLinear-duration-template.csv)         | Unlock-Linear streams with the duration timing.     |
| [Unlock linear with range](https://files.sablier.com/templates/unlockLinear-range-template.csv)               | Unlock-Liner streams with the duration timing.      |
| [Unlock cliff with duration](https://files.sablier.com/templates/2025-02/unlockCliff-duration-template.csv)   | Unlock-Cliff streams with the duration timing.      |
| [Unlock cliff with range](https://files.sablier.com/templates/2025-02/unlockCliff-range-template.csv)         | Unlock-Cliff streams with the range timing.         |
| [Exponential with duration](https://files.sablier.com/templates/exponential-duration-template.csv)            | Exponential streams with the duration timing.       |
| [Exponential with range](https://files.sablier.com/templates/exponential-range-template.csv)                  | Exponential streams with the range timing.          |
| [Cliff exponential with duration](https://files.sablier.com/templates/exponentialCliff-duration-template.csv) | Cliff-Exponential streams with the duration timing. |
| [Cliff exponential with range](https://files.sablier.com/templates/exponentialCliff-range-template.csv)       | Cliff-Exponential streams with the range timing.    |

### Navigation

To use this feature:

1. Access the [vesting gallery](https://app.sablier.com/vesting/gallery/) page in the Sablier app
2. Select the desired vesting shape
3. In the top right corner, you will find a button guiding you toward the CSV feature

|                                                        |
| ------------------------------------------------------ |
| ![CSV Selector](/screenshots/create-csv-selector.webp) |

### Column Formats

To use the CSV feature, the data you provide must be formatted correctly. Bellow is a list with the format expected for
all column types supported by Sablier.

:::warning

Make sure that your CSV editing software (e.g. Microsoft Excel) does not override the cell format. We suggest
double-checking in the Sablier app that the dates have been parsed as expected.

:::

| Column        | Type   | Description                                                                              | Examples                                     |
| :------------ | :----- | :--------------------------------------------------------------------------------------- | :------------------------------------------- |
| address       | String | Recipient address                                                                        | `0x12...AB`                                  |
| amount        | Number | Deposit amount                                                                           | `100`, `42161` or any other valid amount     |
| duration      | String | Total duration                                                                           | `1 year 20 days`, `3 years 20 days 4 hours`  |
| start         | Date   | Start date in `YYYY-MM-DD HH:mm` format                                                  | `2024-02-24 16:15`, `2026-02-14 17:25`       |
| end           | Date   | End date in `YYYY-MM-DD HH:mm` format                                                    | `2024-02-24 16:15`, `2026-02-14 17:25`       |
| cliffDuration | String | Cliff duration                                                                           | `2 years 20 days`, `3 years 20 days 4 hours` |
| cliffEnd      | Date   | Cliff date in `YYYY-MM-DD HH:mm` format                                                  | `2024-02-24 16:15`, `2026-02-14 17:25`       |
| months        | Number | Number of months for the unlock monthly                                                  | `5`, `12` or any other valid integer         |
| steps         | Number | Number of steps for the unlock in steps                                                  | `5`, `12` or any other valid integer         |
| unlock        | Number | Amount that will be initially unlocked                                                   | `100`, `42161` or any other valid amount     |
| initial       | String | Whether the first unlock should occur at the start date or at the end of the first month | `at start` or `end of first month`           |

================
File: docs/api/05-development.mdx
================
---
id: "development"
sidebar_position: 5
title: "Development"
---

import { LinkPreviewIndexers } from "@site/src/components/molecules/link-previews";

## The Graph

### Integrate

To integrate the Sablier indexers into your project, start from the official Sablier Indexers repository.

<LinkPreviewIndexers />

We recommend using:

- [GraphQL Code Generator](https://the-guild.dev/graphql/codegen/docs/getting-started) to create types from your GraphQL
  fragments and queries.
- [TanStack Query](https://tanstack.com/query) to fetch results from the exposed endpoints.

## Envio

### Integrate

To integrate the Envio indexers into your own product, start from the official Sablier Indexers repository. We
recommend using:

- [GraphQL Code Generator](https://the-guild.dev/graphql/codegen/docs/getting-started) to create types from your GraphQL
  fragments and queries
- [TanStack Query](https://tanstack.com/query) to fetch results from the exposed endpoints.

We recommend using request and response wrappers/middleware to format
results coming from Envio's indexer in the same shape as those from The Graph. Suggestions:

1. Write queries in both systems (based on the [querying language specifics](/api/caveats#querying-language)) using the
   same `operationName` and swap query strings between vendors based on it
2. Write response middleware that converts results into similar shapes (see these [important notes](/api/caveats))

<LinkPreviewIndexers />

================
File: docs/support/03-how-to.mdx
================
---
id: "how-to"
sidebar_position: 3
title: "How-to Videos"
---

## Airdrops

### How to Create a Sablier Vested Airdrop Campaign

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/xDTLGGewjNU?si=6TnFL8npi8tRual1"
  title="YouTube video player"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  referrerPolicy="strict-origin-when-cross-origin"
  allowfullscreen
></iframe>

### How to create a Sablier Instant Airdrop Campaign

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/cgEFYDtL3RU?si=s45UcqZ6rNzMdm7i"
  title="YouTube video player"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  referrerPolicy="strict-origin-when-cross-origin"
  allowfullscreen
></iframe>

### How to Claim a Sablier Vested Airdrop

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/vZTDZV8VaaA?si=vYaMrDLfivMin2oM"
  title="YouTube video player"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  referrerPolicy="strict-origin-when-cross-origin"
  allowfullscreen
></iframe>

### How to Claim a Sablier Instant Airdrop

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/vTwqteJ9oAI?si=_izmx7JbFY79_Lv0"
  title="YouTube video player"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  referrerPolicy="strict-origin-when-cross-origin"
  allowfullscreen
></iframe>

## Vesting

### How to Withdraw From a Vesting Stream

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/XIcYied15BM?si=iCO5W7gn4St7RRMk"
  title="YouTube video player"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  referrerPolicy="strict-origin-when-cross-origin"
  allowfullscreen
></iframe>

### How to Create a Vesting Stream

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/0rgYaZhA0is?si=TCyzcthXdDOTjWle"
  title="YouTube video player"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  referrerPolicy="strict-origin-when-cross-origin"
  allowfullscreen
></iframe>

### How to Batch-Cancel Streams

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/fRlUAMx2YFA?si=pklF7Xb2T_9TgPiG"
  title="YouTube video player"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  referrerPolicy="strict-origin-when-cross-origin"
  allowfullscreen
></iframe>

### How to Create Vesting Streams Using the CSV Upload Feature

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/oqjx2muvcX4"
  title="YouTube video player"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  allowfullscreen
></iframe>

### How to Create a Vesting Stream Using a Safe Multisig Wallet

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/z94OHVk-BXU"
  title="YouTube video player"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  allowfullscreen
></iframe>

### How to Trade Vesting Streams on OpenSea

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/S_TTU3VyKOU"
  title="YouTube video player"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  allowfullscreen
></iframe>

### Distribution Shapes & Settings

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/37CZzlnOSRI"
  title="YouTube video player"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  allowfullscreen
></iframe>

## Payments

### How to Withdraw From Payment Streams

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/u8cGre6WW3E?si=IIKcr_tAenmLXi1d"
  title="YouTube video player"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  referrerPolicy="strict-origin-when-cross-origin"
  allowfullscreen
></iframe>

### How to Create Payment Streams

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/z8LFPedx8Kk?si=H1caCFevPCyhma_S"
  title="YouTube video player"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  referrerPolicy="strict-origin-when-cross-origin"
  allowfullscreen
></iframe>

### How to Top Up a Sablier Payment Stream

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/lVSuWR-xC98?si=yh2_0eKpSmMfnpec"
  title="YouTube video player"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  referrerPolicy="strict-origin-when-cross-origin"
  allowfullscreen
></iframe>

### How to Manage Multiple Payment Streams

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/uzZH9UUjtZI?si=XKtb_isfFfac-7TW"
  title="YouTube video player"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  referrerPolicy="strict-origin-when-cross-origin"
  allowfullscreen
></iframe>

## Others

### How to Create a zkSync Proposal Involving a Vesting Stream

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/3mWXLR8qtOs"
  title="YouTube video player"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  allowfullscreen
></iframe>

### Creating a Vesting Stream Using Fireblocks

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/40UZyctH5tY"
  title="YouTube video player"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  allowfullscreen
></iframe>

### Withdrawing Funds From Vesting Stream Using Fireblocks

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/t92yJmT3HkY"
  title="YouTube video player"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  allowfullscreen
></iframe>

### Launching and Vesting Tokens Made Easy with CreateMyToken and Sablier

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/izl9mlsXhpI"
  title="YouTube video player"
  frameBorder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  allowfullscreen
></iframe>

================
File: docs/api/07-legacy.mdx
================
---
id: "legacy"
sidebar_position: 7
title: "Legacy"
---

import LinkPreview from "@site/src/components/molecules/LinkPreview";

# Sablier Legacy Subgraphs

These are the indexers for the [legacy version](/apps/legacy) of Sablier (deployed between 2019-2021). Sablier Legacy is only indexed by The Graph.

## Source Code

<LinkPreview
  href="https://github.com/sablier-labs/legacy-subgraph"
  icon="github"
  subtitle="@sablier-labs/legacy-subgraph"
  title="Sablier Legacy Subgraph"
/>

## Endpoints

{/* TODO: explain API key */}

Endpoints could include: The Graph's Decentralized Network (paid) or Custom Nodes (e.g. Lightlink). Because the
"Decentralized Network" subgraph flavors (e.g. V1 Ethereum) operate on The Graph Network, you will need to
substitute the `YOUR_API_KEY` placeholder in the
[Query URL](https://thegraph.com/docs/en/deploying/subgraph-studio-faqs/#6-how-do-i-find-query-urls-for-subgraphs-if-im-not-the-developer-of-the-subgraph-i-want-to-use)
with your own API key. If you require assistance with managing your API keys and configuring indexer preferences,
[this article](https://thegraph.com/docs/en/studio/managing-api-keys/) serves as an excellent guide

| Chain     | Endpoint URL                           | Studio URL                 |
| --------- | -------------------------------------- | -------------------------- |
| Ethereum  | [sablier][network-ethereum]            | [Studio][studio-ethereum]  |
| Avalanche | [sablier-avalanche][network-avalanche] | [Studio][studio-avalanche] |
| BSC       | [sablier-bsc][network-bsc]             | [Studio][studio-bsc]       |
| Arbitrum  | [sablier-arbitrum][network-arbitrum]   | [Studio][studio-arbitrum]  |
| Optimism  | [sablier-optimism][network-optimism]   | [Studio][studio-optimism]  |
| Polygon   | [sablier-matic][network-polygon]       | [Studio][studio-polygon]   |
| Ronin     | [sablier-ronin][network-ronin]         | N/A                        |

{/* Chain: Ethereum */}

[network-ethereum]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/DkSXWkgJD5qVqfsrfzkLC5WELVX3Dbj3ByWcYjDJieCh
[studio-ethereum]: https://api.studio.thegraph.com/query/57079/sablier/version/latest/

{/* Chain: Arbitrum */}

[network-arbitrum]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/94SP9QVcxmGV9e2fxuTxUGcZfcv4tjpPCGyyPVyMfLP
[studio-arbitrum]: https://api.studio.thegraph.com/query/57079/sablier-arbitrum/version/latest

{/* Chain: Avalanche */}

[network-avalanche]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/DK2gHCprwVaytwzwb5fUrkFS9xy7wh66NX6AFcDzMyF9
[studio-avalanche]: https://api.studio.thegraph.com/query/57079/sablier-avalanche/version/latest

{/* Chain: BSC */}

[network-bsc]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/3Gyy7of99oBRqHcCMGJXpHw2xxxZgXxVmFPFR1vL6YhT
[studio-bsc]: https://api.studio.thegraph.com/query/57079/sablier-bsc/version/latest

{/* Chain: OP Mainnet */}

[network-optimism]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/BEnQbvBdXnohC1DpM9rSb47C1FbowK39HfPNCEHjgrBt
[studio-optimism]: https://api.studio.thegraph.com/query/57079/sablier-optimism/version/latest

{/* Chain: Ronin */}

[network-ronin]: https://subgraph.satsuma-prod.com/d8d041c49d56/sablierlabs/sablier-ronin/api

{/* Chain: Polygon */}

[network-polygon]: https://gateway-arbitrum.network.thegraph.com/api/API_KEY/subgraphs/id/6UMNQfMeh3pV5Qmn2NDX2UKNeUk9kh4oZhzzzn5e8rSz
[studio-polygon]: https://api.studio.thegraph.com/query/57079/sablier-matic/version/latest

{/* Endpoints */}

[^1]:

================
File: docs/api/01-overview.mdx
================
---
id: "overview"
sidebar_position: 1
title: "Overview"
---

import { LinkPreviewIndexers, LinkPreviewMerkleAPI } from "@site/src/components/molecules/link-previews";

# TODOs

- [ ] Explain that the indexers aggregate multiple contract versions

# The Sablier APIs

Sablier relies on specific dependencies to source data and enable off-chain features. All of these are either public or
open-source, so feel free to roam around and suggest improvements or optimizations.

Below, we will cover:

1. The [solutions](#solutions) we use to index and query data
2. The [interface-to-protocol](#products) links between these solutions
3. The raw entities emitted by the contracts

## Solutions

![Banner Sablier APIs](/img/banners/docs-apis.webp)

As an alternative to reading data from the contracts or listening to onchain events, we use a collection of data indexing services. These services act as a middleware between the chain and our interfaces and allow for caching, aggregating, and querying data. For more advanced features like Merkle tree generation (used in Airdrops), we've written our own SDKs and open-sourced some of them.

:::note Playground

To preview the GraphQL APIs for the indexers, you can plug them into
the [Hasura explorer](https://cloud.hasura.io/public/graphiql).
[Here](https://cloud.hasura.io/public/graphiql?endpoint=https://api.studio.thegraph.com/query/112500/sablier-ethereum-lockup/version/latest)'s
an example setup of a Mainnet subgraph for Sablier Lockup.

:::

## Subgraphs

### The Graph

[The Graph](https://thegraph.com/) has been the vendor of choice in the EVM space for some time. We've been
using The Graph since we launched Sablier Legacy in 2019. For our current apps, we created a special set of
feature-oriented subgraphs used internally and by third-party services (e.g., Snapshot) and integrators.

These subgraphs are hosted on The Graph Network, as well as on the The Graph Hosted Service. They can be used to query
Sablier data from the official [indexers](/api/lockup/indexers). Each chain has its own subgraphs.

- [Caveats](/api/caveats)
- [Lockup indexers](/api/lockup/indexers)
- [Flow indexers](/api/lockup/indexers)
- [Airdrops indexers](/api/airdrops/indexers)
- [The Graph docs](https://thegraph.com/docs/en/quick-start/)

<LinkPreviewIndexers />

#### Endpoints / Slugs

Every subgraph deployment will have a `slug` generated by The Graph. The slug is derived from the subgraph name and can
be found in the Studio Development Query URL. We use the following naming convention for subgraphs:

| Subgraph             | Example                   | Product or Concept                             |
| -------------------- | ------------------------- | ---------------------------------------------- |
| `sablier-lockup-*`   | `sablier-lockup-ethereum` | [Lockup](/concepts/lockup/overview) (Vesting)  |
| `sablier-flow-*`     | `sablier-flow-optimism`   | [Flow](/concepts/flow/overview) (Payments)     |
| `sablier-airdrops-*` | `sablier-airdrops-base`   | [Merkle](/concepts/merkle-airdrops) (Airdrops) |
| `sablier-*`          | `sablier-optimism`        | [V1](/api/legacy) (Legacy)                     |

In February 2025, we've deprecated the old line-up of `sablier-v2-*` subgraphs. They remain available (see `Deprecated`
section under each subgraph documentation), but they will not track the most recent deployments nor get future updates.

### Envio

[Envio](https://envio.dev/) offers a suite of fast and flexible tools to access onchain data. Their HyperIndex service
provides a similar GraphQL-driven API to access cached data and serve it into our client interfaces.

We wrote Envio indexers that mirror the features and entities exposed by The Graph subgraphs. This enables us to take advantage of the speed and
optimized environment provided by HyperIndex.

All chains share the same endpoint (for each Sablier protocol, e.g. Lockup).

- [Caveats](/api/caveats)
- [Lockup indexers](/api/lockup/indexers)
- [Flow indexers](/api/lockup/indexers)
- [Airdrops indexers](/api/airdrops/indexers)
- [Envio docs](https://docs.envio.dev)

<LinkPreviewIndexers />

## Merkle API

To support the Merkle distributions in [Airdrops](/apps/features/airdrops), we developed a backend service
called `@sablier/merkle-api`. This API deals with the validation, creation, and management of Merkle trees, which are
used to define eligibility and claiming rules for Sablier's Airstream campaigns.

The service is open-source and can be used by integrators as a plug-n-play solution to support (and even deploy) similar
campaigns. Read more on the dedicated page about the `merkle-api` service [here](/api/airdrops/merkle-api/overview).

- [Indexers](/api/airdrops/indexeres)

<LinkPreviewMerkleAPI />

## App Products

This is how the products available in the Sablier Interface are powered by the different APIs we provide.

### Vesting

The [Vesting](/apps/features/vesting) side of the application is powered by:

- The Graph subgraph for Lockup
- The Envio endpoint for Lockup

### Airdrops

The [Airdrops](/apps/features/airdrops) side of the application is powered by:

- The Graph subgraph for Airdrops
- The Envio endpoint for Airdrops

These handle both Airstreams and Instant Airdrops.

### Payments

The [Payments](/apps/features/payments) side of the application is powered by:

- The Graph subgraph for Flow
- The Envio endpoint for Flow

================
File: docs/concepts/12-fees.mdx
================
---
id: "fees"
sidebar_position: 12
title: "Fees"
---

During the course of using Sablier, you may encounter up to three different types of fees:
[Interface Fees](#interface-fees), [Contract Fees](#contract-fees), and [Gas Fees](#gas-fees). Each of these fees may go
to a different party. Below you can see a breakdown of how each fee is calculated and who receives it.

## Interface Fees

The Sablier Interface charges a flat fee for certain operations. This fee is paid in the native gas token, i.e. in ETH
for streams on Ethereum, and in POL for streams on Polygon.

The fee amount is calculated based on market prices. For example, when ETH is $4000, a $1 fee is 0.00025 ETH.

### Stream Withdrawals

The Sablier Interface charges a flat fee each time you withdraw from a stream. This applies to both Lockup and Flow
streams.

:::tip[What is the withdraw fee?]

The fee is **$1** (in the gas token) regardless of the withdraw amount.

:::

The fee applies only to streams created via Lockup v2.0 (or later) and Flow v1.1 (or later). You do not pay this fee for
withdrawing from streams created using earlier releases.

### Airdrop Claims

The Sablier Interface charges a flat fee when you claim an airdrop.

:::tip[What is the claim fee?]

The fee is **$2** (in the gas token) per claim, regardless of the airdrop amount.

:::

The fee applies only to airdrops created via Merkle Airdrops v1.3 (or later). Claims from airdrops created with earlier
versions do not incur any claim fee.

## Timeline for Interface Fees

| Product  | Timeline                   | Operation     | Fee |
| -------- | -------------------------- | ------------- | --- |
| Airdrops | Apr 10, 2025 - present     | Airdrop claim | $2  |
| Lockup   | Feb 3, 2025 - present      | Withdraw      | $1  |
| Flow     | Feb 3, 2025 - present      | Withdraw      | $1  |
| Airdrops | Feb 3, 2025 - Apr 10, 2025 | Airdrop claim | $3  |
| Airdrops | Dec 18, 2023 - Feb 2, 2025 | Airdrop claim | 0   |
| Lockup   | Jul 3, 2023 - Feb 2, 2025  | Withdraw      | 0   |
| Flow     | Dec 4, 2024 - Feb 2, 2025  | Withdraw      | 0   |

## Contract Fees

As opposed to the Interface fees, the contract fees are charged by the Sablier contracts themselves. They apply
regardless of the interface used to interact with the Sablier Protocol.

This fee is charged via the `msg.value` field. Basically, for the contract to accept a transaction, the `msg.value` must
be greater than or equal to the fee.

:::warning Important

The Contract Fee acts as a **minimum fee**, so it is NOT cumulative with the Interface Fee. You will pay the higher of
the two fees.

:::

### MerkleFactory

The ONLY contracts that can charge fees in Sablier are the `MerkleFactory` contract and the airdrop contracts it
deploys.

The [Protocol Admin](/concepts/governance/) can update the fee in the
[`MerkleFactory`](/reference/airdrops/contracts/contract.SablierMerkleFactory) contract. However, the new fee applies
only to airdrops created after the update. The fee values in the individual airdrop contracts remain immutable once set.

Like the Interface fee, this fee is paid in the native gas token, e.g., ETH on Ethereum, POL on Polygon.

The fee can only be applied to airdrops created with [Merkle Airdrops v1.3](/guides/airdrops/deployments) (or later).
Airdrop campaigns created with earlier versions do not incur any claim fee.

:::tip[What is the fee?]

The fee is ~**$1** (in the gas token) per claim, regardless of the airdrop amount.

:::

| Chain         | Gas Token | Fee              | Fee in Wei          |
| ------------- | --------- | ---------------- | ------------------- |
| Ethereum      | ETH       | 0.00036 ETH      | 360000000000000     |
| Abstract      | ETH       | 0.00036 ETH      | 360000000000000     |
| Arbitrum      | ETH       | 0.00036 ETH      | 360000000000000     |
| Avalanche     | AVAX      | 0.038491147 AVAX | 38491147000000000   |
| Base          | ETH       | 0.00036 ETH      | 360000000000000     |
| Berachain     | BERA      | 0.15385 BERA     | 153850000000000000  |
| Blast         | ETH       | 0.00036 ETH      | 360000000000000     |
| BNB Chain     | BNB       | 0.0017620835 BNB | 1762083500000000    |
| Chiliz        | CHZ       | 9.29 CHZ         | 9290000000000000000 |
| Form          | ETH       | 0 ETH            | 0                   |
| Gnosis        | XDAI      | 1 XDAI           | 1000000000000000000 |
| IoTeX         | IOTX      | 0 IOTX           | 0                   |
| LightLink     | ETH       | 0 ETH            | 0                   |
| Linea         | ETH       | 0.00036 ETH      | 360000000000000     |
| Mode          | ETH       | 0.00036 ETH      | 360000000000000     |
| Morph         | ETH       | 0.00036 ETH      | 360000000000000     |
| Optimism      | ETH       | 0.00036 ETH      | 360000000000000     |
| Polygon       | POL       | 3.1897926635 POL | 3189792663500000000 |
| Scroll        | ETH       | 0.00036 ETH      | 360000000000000     |
| Sei           | SEI       | 0 SEI            | 0                   |
| Sophon        | SOPH      | 0 SOPH           | 0                   |
| Superseed     | ETH       | 0.00036 ETH      | 360000000000000     |
| Taiko Mainnet | ETH       | 0.00036 ETH      | 360000000000000     |
| Tangle        | TNT       | 0 TNT            | 0                   |
| Ultra         | UOS       | 0 UOS            | 0                   |
| Unichain      | ETH       | 0 ETH            | 0                   |
| zkSync Era    | ETH       | 0.00036 ETH      | 360000000000000     |

## Gas Fees

[Gas fees](https://investopedia.com/terms/g/gas-ethereum.asp) are transaction fees paid to the blockchain validators in
the native token of the network, e.g., ETH for Ethereum Mainnet.

Gas is paid only when streams are created, canceled, transferred, or withdrawn from. Gas does not accrue in real-time.

Importantly, Sablier Labs does not take any cut from the gas fee. 100% of the gas fee goes to the blockchain network
validators, which are not affiliated with Sablier Labs.

## FAQ

### Q: How are the Interface Fees charged?

A: They are added to the gas fee. For example, if the gas fee is \$10 and the Interface Fee is \$1, you would pay \$11
in total (the payment is taken in the gas token, e.g., ETH).

### Q: Are the Interface Fees and the Contract Fees cumulative?

A: NO. The Contract Fee acts as a **minimum fee**, so it will not get added to the Interface Fee. You will pay the
higher of the two fees.

### Q: Does the Stream Withdrawal Fee apply to each withdrawal?

A: Yes. The fee is charged each time you withdraw from a stream. For example, if you withdraw from a stream 10 times,
you will pay $10 in fees.

:::tip

We provide gas benchmarks for the [Lockup](/guides/lockup/gas-benchmarks) and [Flow](/guides/flow/gas-benchmarks)
contracts.

:::

================
File: docs/guides/04-custom-deployments.mdx
================
---
id: "custom-deployments"
sidebar_position: 4
title: "Custom Deployments"
---

import Link from "@docusaurus/Link";
import { Links } from "@site/src/constants";

:::info[Reach Out]

{/* prettier-ignore */}
Want to get Sablier deployed on your chain? If you meet the requirements listed below, fill out <Link href={Links.Forms.CHAINS}>this
form</Link> and our team will get back to you.

:::

## Requirements

The Sablier Interface currently supports only The Graph and Envio indexer services. If you use a different indexer, you
can schedule a call <Link href={Links.Forms.CALL}>here</Link> to discuss integration.

- [x] Blockchain explorer with instructions for verifying contracts
- [x] Functional JSON-RPC endpoint, preferably listed on [ChainList](https://chainlist.org)
- [x] GraphQL indexer: specifically, either [The Graph](https://thegraph.com) or [Envio](https://envio.dev)
- [x] Bridge, and instructions for how to obtain gas tokens (e.g., ETH) and ERC-20 tokens to the target chain
- [x] Foundry's [Deterministic Deployer](https://github.com/Arachnid/deterministic-deployment-proxy) contract at
      [`0x4e59b44847b379578588920cA78FbF26c0B4956C`](https://etherscan.io/address/0x4e59b44847b379578588920cA78FbF26c0B4956C)
- [x] [Multicall3](https://github.com/mds1/multicall) contract at
      [`0xcA11bde05977b3631167028862bE2a173976CA11`](https://etherscan.io/address/0xcA11bde05977b3631167028862bE2a173976CA11)

## Making a Deployment

:::warning[NOTE]

The rest of the guide applies ONLY IF you have you been granted a
[BUSL license](https://app.ens.domains/license-grants.sablier.eth?tab=records) to deploy the protocol. Otherwise, this
section is not relevant to you.

:::

### Prerequisites

- Check [here](/guides/lockup/deployments) if the deployment is not already made
- Follow the contributing guides for [Lockup](https://github.com/sablier-labs/lockup/blob/main/CONTRIBUTING.md),
  [Airdrops](https://github.com/sablier-labs/airdrops/blob/main/CONTRIBUTING.md) and
  [Flow](https://github.com/sablier-labs/flow/blob/main/CONTRIBUTING.md).
- RPC endpoint, e.g., a paid [Infura](https://www.infura.io/) or [Alchemy](https://www.alchemy.com/) account
- Have enough ETH in your deployer account
- Have an Etherscan API key (for source code verification)

### Lockup Deployment

#### Step 1: Clone the [Lockup repo](https://github.com/sablier-labs/lockup) and checkout to the `v2.0.0` tag

```bash
git checkout v2.0.0
```

#### Step 2: Create an `.env` file

```bash
touch .env
```

Add the following variables to `.env` file:

```
EOA="DEPLOYER ADDRESS"
ETHERSCAN_API_KEY="EXPLORER API KEY"
PRIVATE_KEY="PRIVATE KEY OF DEPLOYER ADDRESS"
RPC_URL="RPC ENDPOINT URL"
VERIFIER_URL="EXPLORER VERIFICATION URL"
```

Load the environment variables into your shell:

```bash
source .env
```

#### Step 3: Build the contracts

```bash
bun install --frozen-lockfile
```

```bash
bun run build:optimized
```

#### Step 4: Run the following deployment command

For **deterministic** deployment:

```bash
FOUNDRY_PROFILE=optimized \
forge script script/DeployDeterministicProtocol.s.sol \
--broadcast \
--etherscan-api-key $ETHERSCAN_API_KEY \
--rpc-url $RPC_URL \
--private-key $PRIVATE_KEY \
--sig "run()" \
--verifier-url $VERIFIER_URL \
--verify \
-vvv
```

For **non-deterministic** deployment:

```bash
FOUNDRY_PROFILE=optimized \
forge script script/DeployProtocol.s.sol \
--broadcast \
--etherscan-api-key $ETHERSCAN_API_KEY \
--private-key $PRIVATE_KEY \
--rpc-url $RPC_URL \
--sig "run()" \
--verifier-url $VERIFIER_URL \
--verify \
-vvv
```

If you are using a mnemonic or a hardware device for your deployer address, refer to `forge-script` page from
[foundry book](https://book.getfoundry.sh/reference/forge/forge-script#forge-script) for different wallet options.

### Merkle Airdrops Deployment

#### Step 1: Clone the [Merkle Airdrops repo](https://github.com/sablier-labs/airdrops) and checkout to `v1.3.0` tag

```bash
git checkout v1.3.0
```

#### Step 2: Create an `.env` file

```bash
touch .env
```

Add the following variables to `.env` file:

```
EOA="DEPLOYER ADDRESS"
ETHERSCAN_API_KEY="EXPLORER API KEY"
PRIVATE_KEY="PRIVATE KEY OF DEPLOYER ADDRESS"
RPC_URL="RPC ENDPOINT URL"
VERIFIER_URL="EXPLORER VERIFICATION URL"
```

Load the environment variables into shell:

```bash
source .env
```

#### Step 3: Build the contracts

```bash
bun install --frozen-lockfile
```

```bash
bun run build:optimized
```

#### Step 4: Run the following command to deploy all merkle airdrop contracts

For **deterministic** deployments, meaning that CREATE2 is used:

```bash
FOUNDRY_PROFILE=optimized \
forge script script/DeployDeterministicMerkleFactory.s.sol \
--broadcast \
--etherscan-api-key $ETHERSCAN_API_KEY \
--private-key $PRIVATE_KEY \
--rpc-url $RPC_URL \
--sig "run()" \
--verifier-url $VERIFIER_URL \
--verify \
-vvv
```

For **non-deterministic** deployments:

```bash
FOUNDRY_PROFILE=optimized \
forge script script/DeployMerkleFactory.s.sol \
--broadcast \
--etherscan-api-key $ETHERSCAN_API_KEY \
--private-key $PRIVATE_KEY \
--rpc-url $RPC_URL \
--sig "run()" \
--verifier-url $VERIFIER_URL \
--verify \
-vvv
```

If you are using a mnemonic or a hardware device for your deployer address, refer to `forge-script` page from the
[Foundry Book](https://book.getfoundry.sh/reference/forge/forge-script#forge-script).

### Flow Deployment

#### Step 1: Clone the [Flow repo](https://github.com/sablier-labs/flow) and checkout to `v1.1.0` tag

```bash
git checkout v1.1.0
```

#### Step 2: Create an `.env` file

```bash
touch .env
```

Add the following variables to `.env` file:

```
ETH_FROM="DEPLOYER ADDRESS"
ETHERSCAN_API_KEY="EXPLORER API KEY"
PRIVATE_KEY="PRIVATE KEY OF DEPLOYER ADDRESS"
RPC_URL="RPC ENDPOINT URL"
VERIFIER_URL="EXPLORER VERIFICATION URL"
```

Load the environment variables into your shell:

```bash
source .env
```

#### Step 3: Build the contracts

```bash
bun install --frozen-lockfile
```

```bash
bun run build:optimized
```

#### Step 4: Run the following deployment command

For **deterministic** deployment:

```bash
FOUNDRY_PROFILE=optimized \
forge script script/DeployDeterministicFlow.s.sol \
--broadcast \
--etherscan-api-key $ETHERSCAN_API_KEY \
--rpc-url $RPC_URL \
--private-key $PRIVATE_KEY \
--sig "run()" \
--verifier-url $VERIFIER_URL \
--verify \
-vvv
```

For **non-deterministic** deployment:

```bash
FOUNDRY_PROFILE=optimized \
forge script script/DeployFlow.s.sol \
--broadcast \
--etherscan-api-key $ETHERSCAN_API_KEY \
--private-key $PRIVATE_KEY \
--rpc-url $RPC_URL \
--sig "run()" \
--verifier-url $VERIFIER_URL \
--verify \
-vvv
```

If you are using a mnemonic or a hardware device for your deployer address, refer to `forge-script` page from
[foundry book](https://book.getfoundry.sh/reference/forge/forge-script#forge-script) for different wallet options.

### List your deployment

After the contracts are deployed, you can submit your deployment like so:

1. Open a PR in the [docs repo](https://github.com/sablier-labs/docs) by following the listing instructions below.
2. Open a PR in the [deployments repo](https://github.com/sablier-labs/deployments) to add the broadcast file (JSON).
   You can find it in the `broadcast` directory.

#### Listing instructions

When listing a new chain, you need to update the following sections of this documentation site:

- Contract Deployments, e.g. for [Lockup](/guides/lockup/deployments)
- Indexers, e.g. for [Lockup](/api/lockup/indexers)
- [Governance](/concepts/governance)
- [Fees](/concepts/fees)

================
File: docs/concepts/07-chains.mdx
================
---
id: chains
title: Supported Chains
sidebar_position: 7
---

import Link from "@docusaurus/Link";
import Chains from "@site/src/components/organisms/Chains";
import { Links } from "@site/src/constants";
import _ from "lodash";
import { mainnets, testnets } from "sablier";

Sablier Protocol is live on {_.keys(mainnets).length} mainnets and {_.keys(testnets).length} testnets, although not all of these chains are supported by the
[Sablier Interface](https://app.sablier.com/). If you're interested in having your chain listed in the Interface, fill out <Link href={Links.Forms.CALL}>this form</Link>.

## Mainnets

<Chains type="mainnets" />

## Testnets

<Chains type="testnets" />

## Notes

- For more information about these EVM chains, such as RPC URLs, check out [Chainlist](https://chainlist.org).
- Do you want to get Sablier deployed on your chain? If you meet the [requirements](/guides/custom-deployments#requirements)
  for custom deployment, fill out <Link href={Links.Forms.CHAINS}>this form</Link> and our team will get back to you.
- Sablier does not support chains with native tokens that do not have 18 decimals.




================================================================
End of Codebase
================================================================
